---
crate: libgpr
layout: gnatdoc
gnatdoc: {
name: "GPR.Scans",
qualified_name: "GPR.Scans",
signature: "gpr.scans",
enclosing: "gpr",
is_private: false,
documentation: "----------------------------------------------------------------------------\n                                                                          --\n                           GPR PROJECT MANAGER                            --\n                                                                          --\n          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n                                                                          --\n This library is free software;  you can redistribute it and/or modify it --\n under terms of the  GNU General Public License  as published by the Free --\n Software  Foundation;  either version 3,  or (at your  option) any later --\n version. This library is distributed in the hope that it will be useful, --\n but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --\n TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --\n                                                                          --\n As a special exception under Section 7 of GPL version 3, you are granted --\n additional permissions described in the GCC Runtime Library Exception,   --\n version 3.1, as published by the Free Software Foundation.               --\n                                                                          --\n You should have received a copy of the GNU General Public License and    --\n a copy of the GCC Runtime Library Exception along with this program;     --\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n <http://www.gnu.org/licenses/>.                                          --\n                                                                          --\n----------------------------------------------------------------------------",
documentation_snippet: "",
simple_types:    [
       {
       name: "Saved_Scan_State",
       qualified_name: "GPR.Scans.Saved_Scan_State",
       signature: "gpr.scans.saved_scan_state",
       enclosing: "",
       is_private: false,
       documentation: "Used for saving and restoring the scan state",
       documentation_snippet: "type Saved_Scan_State is private;",
       }   ,
       {
       name: "Token_Type",
       qualified_name: "GPR.Scans.Token_Type",
       signature: "gpr.scans.token_type",
       enclosing: "",
       is_private: false,
       documentation: "No_Token is used for initializing Token values to indicate that no value\nhas been set yet.\n\n@enum Tok_Integer_Literal\n@enum Tok_Real_Literal\n@enum Tok_String_Literal\n@enum Tok_Char_Literal\n@enum Tok_Operator_Symbol\n@enum Tok_Identifier\n@enum Tok_Double_Asterisk\n  **\n@enum Tok_Ampersand\n  &\n@enum Tok_Minus\n  -\n@enum Tok_Plus\n  +\n@enum Tok_Asterisk\n  *\n@enum Tok_Mod\n@enum Tok_Rem\n@enum Tok_Slash\n  /\n@enum Tok_New\n@enum Tok_Abs\n@enum Tok_Others\n@enum Tok_Null\n@enum Tok_Raise\n@enum Tok_Dot\n  .\n@enum Tok_Apostrophe\n  '\n@enum Tok_Left_Paren\n  (\n@enum Tok_Delta\n@enum Tok_Digits\n@enum Tok_Range\n@enum Tok_Right_Paren\n  )\n@enum Tok_Comma\n  ,\n@enum Tok_And\n@enum Tok_Or\n@enum Tok_Xor\n@enum Tok_Less\n  <\n@enum Tok_Equal\n  =\n@enum Tok_Greater\n  >\n@enum Tok_Not_Equal\n  /=\n@enum Tok_Greater_Equal\n  >=\n@enum Tok_Less_Equal\n  <=\n@enum Tok_In\n@enum Tok_Not\n@enum Tok_Box\n  <>\n@enum Tok_Colon_Equal\n  :=\n@enum Tok_Colon\n  :\n@enum Tok_Greater_Greater\n  >>\n@enum Tok_Abstract\n@enum Tok_Access\n@enum Tok_Aliased\n@enum Tok_All\n@enum Tok_Array\n@enum Tok_At\n@enum Tok_Body\n@enum Tok_Constant\n@enum Tok_Do\n@enum Tok_Is\n@enum Tok_Interface\n@enum Tok_Limited\n@enum Tok_Of\n@enum Tok_Out\n@enum Tok_Record\n@enum Tok_Renames\n@enum Tok_Reverse\n@enum Tok_Some\n@enum Tok_Tagged\n@enum Tok_Then\n@enum Tok_Less_Less\n  <<\n@enum Tok_Abort\n@enum Tok_Accept\n@enum Tok_Case\n@enum Tok_Delay\n@enum Tok_Else\n@enum Tok_Elsif\n@enum Tok_End\n@enum Tok_Exception\n@enum Tok_Exit\n@enum Tok_Goto\n@enum Tok_If\n@enum Tok_Pragma\n@enum Tok_Requeue\n@enum Tok_Return\n@enum Tok_Select\n@enum Tok_Terminate\n@enum Tok_Until\n@enum Tok_When\n@enum Tok_Begin\n@enum Tok_Declare\n@enum Tok_For\n@enum Tok_Loop\n@enum Tok_While\n@enum Tok_Entry\n@enum Tok_Protected\n@enum Tok_Task\n@enum Tok_Type\n@enum Tok_Subtype\n@enum Tok_Overriding\n@enum Tok_Synchronized\n@enum Tok_Use\n@enum Tok_Function\n@enum Tok_Generic\n@enum Tok_Package\n@enum Tok_Procedure\n@enum Tok_Private\n@enum Tok_With\n@enum Tok_Separate\n@enum Tok_EOF\n@enum Tok_Semicolon\n@enum Tok_Arrow\n  =>\n@enum Tok_Vertical_Bar\n  |\n@enum Tok_Dot_Dot\n  ..\n@enum Tok_Project\n@enum Tok_Extends\n@enum Tok_External\n@enum Tok_External_As_List\n@enum Tok_Comment\n@enum Tok_End_Of_Line\n@enum Tok_Special\n@enum Tok_SPARK_Hide\n@enum No_Token",
       documentation_snippet: "type Token_Type is\n  (Tok_Integer_Literal,\n   Tok_Real_Literal,\n   Tok_String_Literal,\n   Tok_Char_Literal,\n   Tok_Operator_Symbol,\n   Tok_Identifier,\n   Tok_Double_Asterisk,\n   Tok_Ampersand,\n   Tok_Minus,\n   Tok_Plus,\n   Tok_Asterisk,\n   Tok_Mod,\n   Tok_Rem,\n   Tok_Slash,\n   Tok_New,\n   Tok_Abs,\n   Tok_Others,\n   Tok_Null,\n   Tok_Raise,\n   Tok_Dot,\n   Tok_Apostrophe,\n   Tok_Left_Paren,\n   Tok_Delta,\n   Tok_Digits,\n   Tok_Range,\n   Tok_Right_Paren,\n   Tok_Comma,\n   Tok_And,\n   Tok_Or,\n   Tok_Xor,\n   Tok_Less,\n   Tok_Equal,\n   Tok_Greater,\n   Tok_Not_Equal,\n   Tok_Greater_Equal,\n   Tok_Less_Equal,\n   Tok_In,\n   Tok_Not,\n   Tok_Box,\n   Tok_Colon_Equal,\n   Tok_Colon,\n   Tok_Greater_Greater,\n   Tok_Abstract,\n   Tok_Access,\n   Tok_Aliased,\n   Tok_All,\n   Tok_Array,\n   Tok_At,\n   Tok_Body,\n   Tok_Constant,\n   Tok_Do,\n   Tok_Is,\n   Tok_Interface,\n   Tok_Limited,\n   Tok_Of,\n   Tok_Out,\n   Tok_Record,\n   Tok_Renames,\n   Tok_Reverse,\n   Tok_Some,\n   Tok_Tagged,\n   Tok_Then,\n   Tok_Less_Less,\n   Tok_Abort,\n   Tok_Accept,\n   Tok_Case,\n   Tok_Delay,\n   Tok_Else,\n   Tok_Elsif,\n   Tok_End,\n   Tok_Exception,\n   Tok_Exit,\n   Tok_Goto,\n   Tok_If,\n   Tok_Pragma,\n   Tok_Requeue,\n   Tok_Return,\n   Tok_Select,\n   Tok_Terminate,\n   Tok_Until,\n   Tok_When,\n   Tok_Begin,\n   Tok_Declare,\n   Tok_For,\n   Tok_Loop,\n   Tok_While,\n   Tok_Entry,\n   Tok_Protected,\n   Tok_Task,\n   Tok_Type,\n   Tok_Subtype,\n   Tok_Overriding,\n   Tok_Synchronized,\n   Tok_Use,\n   Tok_Function,\n   Tok_Generic,\n   Tok_Package,\n   Tok_Procedure,\n   Tok_Private,\n   Tok_With,\n   Tok_Separate,\n   Tok_EOF,\n   Tok_Semicolon,\n   Tok_Arrow,\n   Tok_Vertical_Bar,\n   Tok_Dot_Dot,\n   Tok_Project,\n   Tok_Extends,\n   Tok_External,\n   Tok_External_As_List,\n   Tok_Comment,\n   Tok_End_Of_Line,\n   Tok_Special,\n   Tok_SPARK_Hide,\n   No_Token);",
       }   ,
   ]
,array_types:    [
       {
       name: "Token_Flag_Array",
       qualified_name: "GPR.Scans.Token_Flag_Array",
       signature: "gpr.scans.token_flag_array",
       enclosing: "",
       is_private: false,
       documentation: "Flag array used to test for reserved word",
       documentation_snippet: "type Token_Flag_Array is array (Token_Type) of Boolean;",
       }   ,
   ]
,subtypes:    [
       {
       name: "Token_Class_Cunit",
       qualified_name: "GPR.Scans.Token_Class_Cunit",
       signature: "gpr.scans.token_class_cunit",
       enclosing: "",
       is_private: false,
       documentation: "Tokens which can begin a compilation unit",
       documentation_snippet: "subtype Token_Class_Cunit is\n  Token_Type range Tok_Function .. Tok_Separate;",
       }   ,
       {
       name: "Token_Class_Literal",
       qualified_name: "GPR.Scans.Token_Class_Literal",
       signature: "gpr.scans.token_class_literal",
       enclosing: "",
       is_private: false,
       documentation: "Literal",
       documentation_snippet: "subtype Token_Class_Literal is\n  Token_Type range Tok_Integer_Literal .. Tok_Operator_Symbol;",
       }   ,
   ]
,constants:    [
       {
       name: "Is_Reserved_Keyword",
       qualified_name: "GPR.Scans.Is_Reserved_Keyword",
       signature: "gpr.scans.is_reserved_keyword",
       enclosing: "",
       is_private: false,
       documentation: "Flag array used to test for reserved word",
       documentation_snippet: "Is_Reserved_Keyword : constant Token_Flag_Array :=\n  Token_Flag_Array'\n    (Tok_Mod      .. Tok_Rem      => True,\n     Tok_New      .. Tok_Null     => True,\n     Tok_Delta    .. Tok_Range    => True,\n     Tok_And      .. Tok_Xor      => True,\n     Tok_In       .. Tok_Not      => True,\n     Tok_Abstract .. Tok_Then     => True,\n     Tok_Abort    .. Tok_Separate => True,\n     others                       => False);",
       }   ,
   ]
,variables:    [
       {
       name: "Character_Code",
       qualified_name: "GPR.Scans.Character_Code",
       signature: "gpr.scans.character_code",
       enclosing: "",
       is_private: false,
       documentation: "Valid only when Token is Tok_Char_Literal. Contains the value of the\nscanned literal.",
       documentation_snippet: "Character_Code : Char_Code;",
       }   ,
       {
       name: "Checksum",
       qualified_name: "GPR.Scans.Checksum",
       signature: "gpr.scans.checksum",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Used to accumulate a CRC representing the tokens in the source file\n being compiled. This CRC includes only program tokens, and excludes\n comments.",
       documentation_snippet: "Checksum : Word := 0;",
       }   ,
       {
       name: "Comment_Id",
       qualified_name: "GPR.Scans.Comment_Id",
       signature: "gpr.scans.comment_id",
       enclosing: "",
       is_private: false,
       documentation: "Valid only when Token = Tok_Comment. Store the string that follows the\n\"--\" of a comment when scanning project files.",
       documentation_snippet: "Comment_Id : Name_Id := No_Name;",
       }   ,
       {
       name: "Current_Line_Start",
       qualified_name: "GPR.Scans.Current_Line_Start",
       signature: "gpr.scans.current_line_start",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Pointer to first character of line containing current token",
       documentation_snippet: "Current_Line_Start : Source_Ptr := No_Location;",
       }   ,
       {
       name: "First_Non_Blank_Location",
       qualified_name: "GPR.Scans.First_Non_Blank_Location",
       signature: "gpr.scans.first_non_blank_location",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Location of first non-blank character on the line containing the current\n token (i.e. the location of the character whose column number is stored\n in Start_Column).",
       documentation_snippet: "First_Non_Blank_Location : Source_Ptr := No_Location;",
       }   ,
       {
       name: "Int_Literal_Value",
       qualified_name: "GPR.Scans.Int_Literal_Value",
       signature: "gpr.scans.int_literal_value",
       enclosing: "",
       is_private: false,
       documentation: "Valid only when Token = Tok_Integer_Literal, contains the value of the\nscanned literal.",
       documentation_snippet: "Int_Literal_Value : Int;",
       }   ,
       {
       name: "Prev_Token",
       qualified_name: "GPR.Scans.Prev_Token",
       signature: "gpr.scans.prev_token",
       enclosing: "",
       is_private: false,
       documentation: "Type of previous token",
       documentation_snippet: "Prev_Token : Token_Type := No_Token;",
       }   ,
       {
       name: "Prev_Token_Ptr",
       qualified_name: "GPR.Scans.Prev_Token_Ptr",
       signature: "gpr.scans.prev_token_ptr",
       enclosing: "",
       is_private: false,
       documentation: "Pointer to first character of previous token",
       documentation_snippet: "Prev_Token_Ptr : Source_Ptr;",
       }   ,
       {
       name: "Scan_Ptr",
       qualified_name: "GPR.Scans.Scan_Ptr",
       signature: "gpr.scans.scan_ptr",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Current scan pointer location. After a call to Scan, this points\n just past the end of the token just scanned.",
       documentation_snippet: "Scan_Ptr : Source_Ptr := No_Location;",
       }   ,
       {
       name: "Special_Character",
       qualified_name: "GPR.Scans.Special_Character",
       signature: "gpr.scans.special_character",
       enclosing: "",
       is_private: false,
       documentation: "Valid only when Token = Tok_Special. Returns one of the characters\n'#', '$', '?', '@', '`', '\\', '^', '~', or '_'.",
       documentation_snippet: "Special_Character : Character;",
       }   ,
       {
       name: "Start_Column",
       qualified_name: "GPR.Scans.Start_Column",
       signature: "gpr.scans.start_column",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Starting column number (zero origin) of the first non-blank character on\n the line containing the current token. This is used for error recovery\n circuits which depend on looking at the column line up.",
       documentation_snippet: "Start_Column : Column_Number := No_Column_Number;",
       }   ,
       {
       name: "Token",
       qualified_name: "GPR.Scans.Token",
       signature: "gpr.scans.token",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Type of current token",
       documentation_snippet: "Token : Token_Type := No_Token;",
       }   ,
       {
       name: "Token_Name",
       qualified_name: "GPR.Scans.Token_Name",
       signature: "gpr.scans.token_name",
       enclosing: "",
       is_private: false,
       documentation: "For identifiers, this is set to the Name_Id of the identifier scanned.\nFor all other tokens, Token_Name is set to Error_Name. Note that it\nwould be possible for the caller to extract this information from\nToken_Node. We set Token_Name separately for two reasons. First it\nallows a quicker test for a specific identifier. Second, it allows a\nversion of the parser to be built that does not build tree nodes,\nusable as a syntax checker.",
       documentation_snippet: "Token_Name : Name_Id := No_Name;",
       }   ,
       {
       name: "Token_Node",
       qualified_name: "GPR.Scans.Token_Node",
       signature: "gpr.scans.token_node",
       enclosing: "",
       is_private: false,
       documentation: "Node table Id for the current token. This is set only if the current\ntoken is one for which the scanner constructs a node (i.e. it is\nan identifier, operator symbol, or literal). For other token types,\nToken_Node is undefined.",
       documentation_snippet: "Token_Node : Node_Id := Empty_Node;",
       }   ,
       {
       name: "Token_Ptr",
       qualified_name: "GPR.Scans.Token_Ptr",
       signature: "gpr.scans.token_ptr",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Pointer to first character of current token",
       documentation_snippet: "Token_Ptr : Source_Ptr := No_Location;",
       }   ,
       {
       name: "Type_Token_Location",
       qualified_name: "GPR.Scans.Type_Token_Location",
       signature: "gpr.scans.type_token_location",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Within a type declaration, gives the location of the TYPE keyword that\n opened the type declaration. Used in checking the end column of a record\n declaration, which can line up either with the TYPE keyword, or with the\n start of the line containing the RECORD keyword.",
       documentation_snippet: "Type_Token_Location : Source_Ptr := No_Location;",
       }   ,
   ]
,}
---
