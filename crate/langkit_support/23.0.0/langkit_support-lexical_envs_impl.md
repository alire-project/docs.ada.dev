---
crate: langkit_support
layout: gnatdoc
gnatdoc: {
name: "Langkit_Support.Lexical_Envs_Impl",
qualified_name: "Langkit_Support.Lexical_Envs_Impl",
signature: "langkit_support.lexical_envs_impl",
enclosing: "langkit_support",
is_private: false,
documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0\n\n@formal Get_Unit_Version\n  Used to retrieve the version number of the given Unit, for cache\n  invalidation purposes.\n@formal Node_Type\n@formal Node_Metadata\n@formal No_Node\n@formal Empty_Metadata\n@formal \"<\"\n@formal \"=\"\n@formal Ref_Category\n@formal Ref_Categories\n@formal Node_Unit\n@formal Node_Hash\n@formal Metadata_Hash\n@formal Combine\n@formal Can_Reach\n  Function that will allow filtering nodes depending on the origin node of\n  the request. In practice, this is used to implement sequential semantics\n  for lexical envs, as-in, node declared after another is not yet visible.\n@formal Is_Rebindable\n  Return whether a lexical environment whose node is Node can be rebound\n@formal Node_Text_Image\n@formal Acquire_Rebinding\n  Allocate if needed, initialize return a record to store env rebindings\n@formal Register_Rebinding\n  Register a rebinding to be destroyed when Node is destroyed\n@formal Get_Context_Version\n  Return the current version number of caches corresponding to Node's\n  context, for cache invalidation purposes.\n@formal Inner_Env_Assoc\n@formal Get_Key\n@formal Get_Node\n@formal Get_Metadata\n@formal Inner_Env_Assoc_Array\n@formal Length\n@formal Get\n@formal Dec_Ref\n@formal Properties_May_Raise",
documentation_snippet: "",
simple_types:    [
       {
       name: "Lookup_Cache_Entry_State",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Lookup_Cache_Entry_State",
       signature: "langkit_support.lexical_envs_impl.lookup_cache_entry_state",
       enclosing: "",
       is_private: false,
       documentation: "Status of an entry in lexical environment lookup caches.\n\nComputing represents the dummy entry that is inserted during original\ncomputation. That means that a cache hit that returns a Computing entry\nreveals an infinite recursion (a lexical environment lookup that calls\nitself recursively).\n\nComputed represents an entry whose elements are fine to be used as a\ncache hit.\n\nNone represents a cleared cache entry, i.e. getting it out of a cache\nmeans there's a cache miss. Using this state instead of just removing\nthe cache is used to avoid destroying the cache map when clearing\ncaches.\n\n@enum Computing\n@enum Computed\n@enum None",
       documentation_snippet: "type Lookup_Cache_Entry_State is (Computing, Computed, None);",
       }   ,
   ]
,array_types:    [
       {
       name: "Node_Array",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Node_Array",
       signature: "langkit_support.lexical_envs_impl.node_array",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Node_Array is array (Positive range <>) of Node_Type;",
       }   ,
   ]
,record_types:    [
       {
       name: "Entity",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Entity",
       signature: "langkit_support.lexical_envs_impl.entity",
       enclosing: "",
       is_private: false,
       documentation: "Wrapper structure to contain both the 'real' node that the user wanted\nto store, and its associated metadata.\n\n@field Node\n@field Info",
       documentation_snippet: "type Entity is record\n   Node : Node_Type;\n   Info : Entity_Info;\nend record;",
       }   ,
       {
       name: "Entity_Info",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Entity_Info",
       signature: "langkit_support.lexical_envs_impl.entity_info",
       enclosing: "",
       is_private: false,
       documentation: "\n@field Md\n  External metadata for the node\n@field Rebindings\n  Rebindings applying to this entity\n@field From_Rebound",
       documentation_snippet: "type Entity_Info is record\n   Md : Node_Metadata;\n   Rebindings : Env_Rebindings := null;\n   From_Rebound : Boolean := False;\nend record\n   with Convention => C;",
       }   ,
       {
       name: "Env_Getter",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Env_Getter",
       signature: "langkit_support.lexical_envs_impl.env_getter",
       enclosing: "",
       is_private: false,
       documentation: "Link to an environment. It can be either a simple link (just a pointer)\nor a dynamic link (a function that recomputes the link when needed). See\nthe two constructors below.\n\n@field Dynamic\n@field Env\n  If Dynamic, cache for the resolved lexical environment. To be used\n  only when No_Entity_Info is used for the resolution. We consider that\n  this cache contains a valid entry when Env is not Null_Lexical_Env\n  and that it is not stale.\n  \n  Note that we process Empty_Env in a very specific way here: resolvers\n  often return Empty_Env when they fail to compute the result, for\n  instance because of a missing unit. When that unit is parsed, we want\n  to invalidate the cache (the Env component) so that the resolver has\n  another chance to fetch the result from that new unit.\n  \n  To achieve this, when putting Empty_Env in the cache, we set\n  Env.Version to the version of the owning context, and when trying to\n  use the cache, we check that the version is still the same.\n  \n  We do not have this problem with other envs thanks to their own unit\n  version number (Empty_Env is a global singleton, so it does not has a\n  owning unit nor an owning context).\n@field Node\n  Data and callable to resolve this getter\n@field Resolver\n  Data and callable to resolve this getter",
       documentation_snippet: "type Env_Getter (Dynamic : Boolean := False) is record\n   Env : Lexical_Env := Null_Lexical_Env;\n   case Dynamic is\n      when True =>\n         Node     : Node_Type;\n         Resolver : Lexical_Env_Resolver;\n      when False =>\n         null;\n   end case;\nend record;",
       }   ,
       {
       name: "Internal_Map_Element",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Internal_Map_Element",
       signature: "langkit_support.lexical_envs_impl.internal_map_element",
       enclosing: "",
       is_private: false,
       documentation: "Set of nodes associated to a symbol in a lexical environment\n\n@field Native_Nodes\n  List of node that belong to the same unit as the lexical env that\n  owns the map.\n@field Foreign_Nodes",
       documentation_snippet: "type Internal_Map_Element is record\n   Native_Nodes : Internal_Map_Node_Vectors.Vector;\n   Foreign_Nodes : Internal_Map_Node_Map := null;\nend record;",
       }   ,
       {
       name: "Internal_Map_Node",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Internal_Map_Node",
       signature: "langkit_support.lexical_envs_impl.internal_map_node",
       enclosing: "",
       is_private: false,
       documentation: "\n@field Node\n  If Resolver is null, this is the node that lexical env lookup must\n  return. Otherwise, it is the argument to pass to Resolver in order to\n  get the result.\n@field Md\n  Metadata associated to Node\n@field Resolver",
       documentation_snippet: "type Internal_Map_Node is record\n   Node : Node_Type;\n   Md : Node_Metadata;\n   Resolver : Entity_Resolver;\nend record;",
       }   ,
       {
       name: "Lookup_Cache_Entry",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Lookup_Cache_Entry",
       signature: "langkit_support.lexical_envs_impl.lookup_cache_entry",
       enclosing: "",
       is_private: false,
       documentation: "Result of a lexical environment lookup\n\n@field State\n@field Elements",
       documentation_snippet: "type Lookup_Cache_Entry is record\n   State    : Lookup_Cache_Entry_State;\n   Elements : Lookup_Result_Item_Vectors.Vector;\nend record;",
       }   ,
       {
       name: "Lookup_Cache_Key",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Lookup_Cache_Key",
       signature: "langkit_support.lexical_envs_impl.lookup_cache_key",
       enclosing: "",
       is_private: false,
       documentation: "Key in environment lookup caches. Basically the parameters for the Get\nfunctiont that are relevant for caching.\n\n@field Symbol\n  Symbol for this lookup\n@field Rebindings\n  Rebindings used for this lookup\n@field Metadata\n  Metadata used for this lookup\n@field Categories",
       documentation_snippet: "type Lookup_Cache_Key is record\n   Symbol : Symbol_Type;\n   Rebindings : Env_Rebindings;\n   Metadata : Node_Metadata;\n   Categories : Ref_Categories := All_Cats;\nend record;",
       }   ,
       {
       name: "Lookup_Result_Item",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Lookup_Result_Item",
       signature: "langkit_support.lexical_envs_impl.lookup_result_item",
       enclosing: "",
       is_private: false,
       documentation: "Lexical environment lookup result item. Lookups return arrays of these.\n\n@field E\n  Returned entity\n@field Filter_From\n  Whether to filter with Can_Reach\n@field Override_Filter_Node",
       documentation_snippet: "type Lookup_Result_Item is record\n   E : Entity;\n   Filter_From : Boolean;\n   Override_Filter_Node : Node_Type := No_Node;\nend record;",
       }   ,
       {
       name: "Referenced_Env",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Referenced_Env",
       signature: "langkit_support.lexical_envs_impl.referenced_env",
       enclosing: "",
       is_private: false,
       documentation: "Represents a referenced env\n\n@field Kind\n  Kind for this referenced env\n@field Getter\n  Closure to fetch the environment that is referenced\n@field Being_Visited\n  Flag set to true when Referenced_Env is being visited. Used as a\n  recursion guard. WARNING: Not thread safe.\n@field State\n  State of the referenced env, whether active or inactive\n@field Categories",
       documentation_snippet: "type Referenced_Env is record\n   Kind : Ref_Kind := Normal;\n   Getter : Env_Getter;\n   Being_Visited : Boolean;\n   State : Refd_Env_State := Inactive;\n   Categories : Ref_Categories := All_Cats;\nend record;",
       }   ,
   ]
,tagged_types:    [
       {
       name: "Lexical_Env_Record",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Lexical_Env_Record",
       signature: "langkit_support.lexical_envs_impl.lexical_env_record",
       enclosing: "",
       is_private: false,
       documentation: "\n@field Kind\n@field Parent\n  Parent environment for this env. Null by default.\n@field Transitive_Parent\n  Whether the parent link is transitive or not\n@field Node\n  Node for which this environment was created\n@field Rebindings_Pool\n  Cache for all parent-less env rebindings whose Old_Env is the\n  lexical environment that owns this pool. As a consequence, this\n  is allocated only for primary lexical environments that are\n  rebindable.\n@field Lookup_Cache\n  Cache for lexical environment lookups\n@field Lookup_Cache_Valid\n  Whether Cached_Results contains lookup results that can\n  be currently reused (i.e. whether they are not stale).\n@field Referenced_Envs\n  A list of environments referenced by this environment\n@field Rebindings_Assoc_Ref_Env\n  If present, index to the Referenced_Envs vector that\n  points to an environment we want to look at when shedding\n  rebindings. If the referenced env is not none, it will be\n  considered in place of Self when shedding rebindings.\n@field Map\n  Map containing mappings from symbols to nodes for this\n  env instance. If the lexical env is refcounted, then it\n  does not own this env.\n@field Assocs_Getter\n  Callback to query environment associations\n@field Assoc_Resolver\n  Callback to resolve returned entities\n@field Ref_Count\n  Number of owners. It is initially set to 1. When it drops to 0,\n  the env can be destroyed.\n@field Orphaned_Env\n  Lexical environment that is orphaned\n@field Grouped_Envs\n  Array of lexical environment that are grouped together\n@field Default_Md\n  Default metadata to use for lookups\n@field Rebound_Env\n  Lexical environment that is rebound\n@field Rebindings\n  Rebindings for this rebound environment\n@field Rebindings_Version",
       documentation_snippet: "type Lexical_Env_Record (Kind : Lexical_Env_Kind) is\n   new Base_Lexical_Env_Record\nwith record\n   case Kind is\n      when Primary_Kind =>\n         Parent : Lexical_Env := Null_Lexical_Env;\n         Transitive_Parent : Boolean := False;\n         Node : Node_Type := No_Node;\n         Rebindings_Pool : Env_Rebindings_Pool := null;\n         case Kind is\n            when Static_Primary =>\n               Lookup_Cache : Lookup_Cache_Maps.Map;\n               Lookup_Cache_Valid : Boolean := True;\n               Referenced_Envs : Referenced_Envs_Vectors.Vector;\n               Rebindings_Assoc_Ref_Env : Integer := -1;\n               Map : Internal_Map := null;\n            when Dynamic_Primary =>\n               Assocs_Getter : Inner_Env_Assocs_Resolver;\n               Assoc_Resolver : Entity_Resolver;\n            when others =>\n               null;\n         end case;\n      when others =>\n         Ref_Count : Integer := 1;\n         case Kind is\n            when Primary_Kind =>\n               null;\n            when Orphaned =>\n               Orphaned_Env : Lexical_Env;\n            when Grouped =>\n               Grouped_Envs : Lexical_Env_Array_Access;\n               Default_Md : Node_Metadata := Empty_Metadata;\n            when Rebound =>\n               Rebound_Env : Lexical_Env;\n               Rebindings : Env_Rebindings;\n               Rebindings_Version : Version_Number;\n         end case;\n   end case;\nend record;",
       }   ,
   ]
,access_types:    [
       {
       name: "Entity_Resolver",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Entity_Resolver",
       signature: "langkit_support.lexical_envs_impl.entity_resolver",
       enclosing: "",
       is_private: false,
       documentation: "Callback type for the lazy entity resolution mechanism. Such functions\nmust take a \"reference\" entity (e.g. a name) and return the referenced\nentity.\n\n@param Ref\n\n@return",
       documentation_snippet: "type Entity_Resolver is access function (Ref : Entity) return Entity;",
       }   ,
       {
       name: "Inner_Env_Assocs_Resolver",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Inner_Env_Assocs_Resolver",
       signature: "langkit_support.lexical_envs_impl.inner_env_assocs_resolver",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Inner_Env_Assocs_Resolver is\n   access function (Self : Entity) return Inner_Env_Assoc_Array;",
       }   ,
       {
       name: "Internal_Map",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Internal_Map",
       signature: "langkit_support.lexical_envs_impl.internal_map",
       enclosing: "",
       is_private: false,
       documentation: "Internal maps of Symbols to vectors of nodes",
       documentation_snippet: "type Internal_Map is access all Internal_Envs.Map;",
       }   ,
       {
       name: "Internal_Map_Node_Map",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Internal_Map_Node_Map",
       signature: "langkit_support.lexical_envs_impl.internal_map_node_map",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Internal_Map_Node_Map is access all Internal_Map_Node_Maps.Map;",
       }   ,
       {
       name: "Lexical_Env_Access",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Lexical_Env_Access",
       signature: "langkit_support.lexical_envs_impl.lexical_env_access",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Lexical_Env_Access is access all Lexical_Env_Record;",
       }   ,
       {
       name: "Lexical_Env_Array_Access",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Lexical_Env_Array_Access",
       signature: "langkit_support.lexical_envs_impl.lexical_env_array_access",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Lexical_Env_Array_Access is access all Lexical_Env_Array;",
       }   ,
       {
       name: "Lexical_Env_Resolver",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Lexical_Env_Resolver",
       signature: "langkit_support.lexical_envs_impl.lexical_env_resolver",
       enclosing: "",
       is_private: false,
       documentation: "Callback type for the lazy referenced env resolution mechanism\n\n@param Ref\n\n@return",
       documentation_snippet: "type Lexical_Env_Resolver is access\n  function (Ref : Entity) return Lexical_Env;",
       }   ,
   ]
,subtypes:    [
       {
       name: "Entity_Array",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Entity_Array",
       signature: "langkit_support.lexical_envs_impl.entity_array",
       enclosing: "",
       is_private: false,
       documentation: "Arrays of wrapped nodes stored in the environment maps",
       documentation_snippet: "subtype Entity_Array is Entity_Vectors.Elements_Array;",
       }   ,
       {
       name: "Internal_Map_Node_Array",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Internal_Map_Node_Array",
       signature: "langkit_support.lexical_envs_impl.internal_map_node_array",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype Internal_Map_Node_Array is\n   Internal_Map_Node_Vectors.Elements_Array;",
       }   ,
       {
       name: "Lookup_Result_Array",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Lookup_Result_Array",
       signature: "langkit_support.lexical_envs_impl.lookup_result_array",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype Lookup_Result_Array  is\n   Lookup_Result_Item_Vectors.Elements_Array;",
       }   ,
       {
       name: "Lookup_Result_Vector",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Lookup_Result_Vector",
       signature: "langkit_support.lexical_envs_impl.lookup_result_vector",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype Lookup_Result_Vector is Lookup_Result_Item_Vectors.Vector;",
       }   ,
   ]
,constants:    [
       {
       name: "Empty_Env",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Empty_Env",
       signature: "langkit_support.lexical_envs_impl.empty_env",
       enclosing: "",
       is_private: false,
       documentation: "Empty_Env is a magical lexical environment that will always be empty. We\nallow users to call Add on it anyway as a convenience, but this is a\nno-op. This makes sense as Empty_Env's purpose is to be used to\nrepresent missing scopes from erroneous trees.",
       documentation_snippet: "Empty_Env : constant Lexical_Env;",
       }   ,
       {
       name: "Empty_Internal_Map_Element",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Empty_Internal_Map_Element",
       signature: "langkit_support.lexical_envs_impl.empty_internal_map_element",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Empty_Internal_Map_Element : constant Internal_Map_Element :=\n  (others => <>);",
       }   ,
       {
       name: "No_Env_Getter",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.No_Env_Getter",
       signature: "langkit_support.lexical_envs_impl.no_env_getter",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "No_Env_Getter : constant Env_Getter := (False, Null_Lexical_Env);",
       }   ,
       {
       name: "No_Lookup_Cache_Entry",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.No_Lookup_Cache_Entry",
       signature: "langkit_support.lexical_envs_impl.no_lookup_cache_entry",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "No_Lookup_Cache_Entry : constant Lookup_Cache_Entry :=\n  (None, Empty_Lookup_Result_Vector);",
       }   ,
   ]
,variables:    [
       {
       name: "All_Cats",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.All_Cats",
       signature: "langkit_support.lexical_envs_impl.all_cats",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "All_Cats : Ref_Categories := (others => True);",
       }   ,
       {
       name: "Empty_Lookup_Result_Array",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Empty_Lookup_Result_Array",
       signature: "langkit_support.lexical_envs_impl.empty_lookup_result_array",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Empty_Lookup_Result_Array : Lookup_Result_Array renames\n   Lookup_Result_Item_Vectors.Empty_Array;",
       }   ,
       {
       name: "Empty_Lookup_Result_Vector",
       qualified_name: "Langkit_Support.Lexical_Envs_Impl.Empty_Lookup_Result_Vector",
       signature: "langkit_support.lexical_envs_impl.empty_lookup_result_vector",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Empty_Lookup_Result_Vector : Lookup_Result_Vector renames\n   Lookup_Result_Item_Vectors.Empty_Vector;",
       }   ,
   ]
,}
---
