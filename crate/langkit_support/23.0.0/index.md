---
crate: langkit_support
layout: gnatdoc_index
gnatdoc: {packages: [
    {
    name: "Langkit_Support",
    qualified_name: "Langkit_Support",
    signature: "langkit_support",
    enclosing: "",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Adalog",
    qualified_name: "Langkit_Support.Adalog",
    signature: "langkit_support.adalog",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Adalog.Debug",
    qualified_name: "Langkit_Support.Adalog.Debug",
    signature: "langkit_support.adalog.debug",
    enclosing: "langkit_support.adalog",
    is_private: false,
    documentation: "This package Contains the debug configuration for Adalog. There are two\nmain ways of configuring the debug mode in Adalog:\n\n- The Debug_Enabled constant will determine at compile time whether\n  debugging is enabled or not. If it is False, no traces will be output,\n  and the Step mode won't be usable.\n- If you set the Debug_Enabled constant to True, you still need to activate\n  a debug mode at runtime via Set_Debug_State.",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Adalog.Generic_Main_Support",
    qualified_name: "Langkit_Support.Adalog.Generic_Main_Support",
    signature: "langkit_support.adalog.generic_main_support",
    enclosing: "langkit_support.adalog",
    is_private: false,
    documentation: "Provide common support material for Adalog unit tests\n\n@formal T\n@formal Image",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Adalog.Logic_Var",
    qualified_name: "Langkit_Support.Adalog.Logic_Var",
    signature: "langkit_support.adalog.logic_var",
    enclosing: "langkit_support.adalog",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0\n\n@formal Value_Type\n  Type of the values associated to variables, assumed to have by-reference\n  semantics.\n@formal Inc_Ref\n@formal Dec_Ref\n  Associated ref-counting primitives\n@formal Value_Image\n  Image of values, for debugging purposes",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Adalog.Solver",
    qualified_name: "Langkit_Support.Adalog.Solver",
    signature: "langkit_support.adalog.solver",
    enclosing: "langkit_support.adalog",
    is_private: false,
    documentation: "\nCopyright (C) 2019-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Adalog.Solver_Interface",
    qualified_name: "Langkit_Support.Adalog.Solver_Interface",
    signature: "langkit_support.adalog.solver_interface",
    enclosing: "langkit_support.adalog",
    is_private: false,
    documentation: "-----------------\n Functor types --\n-----------------",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Array_Utils",
    qualified_name: "Langkit_Support.Array_Utils",
    signature: "langkit_support.array_utils",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "This package provides a standardized array type (starting at index 0) along\nwith a host of functional primitives to manipulate instances of this\narray. Functional transformations are a more natural way to express some\ntransformations (filters for example), and, thanks to Ada's secondary stack\nbased arrays, can be much faster than the dynamic vector counterpart.\n\nFor example, given the following imperative code::\n\n   Input  : Vector;\n   Output : Vector;\n\n   for El of Input loop\n      if Predicate (El) then\n         Output.Append (El);\n      end if;\n   end loop;\n\nYou could do the same thing in a functional way with this module, like so::\n\n   Input  : Array_Type;\n   Output : Array_Type := Filter (Input, Predicate'Access)\n\nThe module generally provides two ways to use a higher order primitive:\n\n1. The first is by using the dynamic version of the primitive, that takes\n   an access to the subprogram(s) it is going to need. For filter, it will\n   be the Filter primitive.\n\n2. The second is to use the generic version of the primitive, that will\n   take the subprograms as generic parameters. Those versions end with the\n   _Gen suffix. For filter, it will be Filter_Gen. Those versions are\n   faster, because the front-end is able to inline the parameter\n   subprograms inside the call.\n\n@formal Element_Type\n@formal Index_Type\n@formal Array_Type\n@formal \"=\"",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Boxes",
    qualified_name: "Langkit_Support.Boxes",
    signature: "langkit_support.boxes",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "This package provides a simple implementation for boxing types: types that\nare dynamically allocated, handled by reference and with automatic memory\nmanagement thanks to reference counting.\n\nThe main difference with GNATCOLL.Refcount is that here, Element_Type is\nlimited and constrained while in GNATCOLL.Refcount, Element_Type is not\nlimited and unconstrained.\n\n@formal Element_Type\n  The type to be boxed\n@formal Refcount\n  Return Self's reference count\n@formal Set_Refcount\n  Set Self's reference count to Count\n@formal Release\n  Release all resources in Element_Type. This is called when the reference\n  count drops to 0.",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Bump_Ptr_Vectors",
    qualified_name: "Langkit_Support.Bump_Ptr_Vectors",
    signature: "langkit_support.bump_ptr_vectors",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "Beware though, random access is still on the average of 100x slower than in\norder iteration, so *never* use Get_At_Index to iterate over the vector!\n\n@formal Element_Type",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Cheap_Sets",
    qualified_name: "Langkit_Support.Cheap_Sets",
    signature: "langkit_support.cheap_sets",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0\n\n@formal Element_Type\n@formal No_Element\n@formal \"=\"",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Diagnostics",
    qualified_name: "Langkit_Support.Diagnostics",
    signature: "langkit_support.diagnostics",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Diagnostics.Output",
    qualified_name: "Langkit_Support.Diagnostics.Output",
    signature: "langkit_support.diagnostics.output",
    enclosing: "langkit_support.diagnostics",
    is_private: false,
    documentation: "This package supports outputting\n:ada:ref:`Langkit_Support.Diagnostics.Diagnostic` for a source buffer, in a\npretty colorized format akin to GCC's verbose diagnostic format.\n\n.. note:: For the moment, this package has a few limitations, namely:\n\n    - Only source buffers with ``LF`` line endings are handled.\n\n    - Only error messages spanning one line are gracefully handled.\n      eventually we want to have something more powerful that has a syntax\n      for error spanning multiple lines.\n\n.. todo:\n\n    For the moment this is only used in the ``lkt_toolbox`` executable.\n    Eventually, this should be exposed to generated library users in some\n    fashion.",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Errors",
    qualified_name: "Langkit_Support.Errors",
    signature: "langkit_support.errors",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "This package contains definitions for exceptions common to all\nLangkit-generated libraries.",
    documentation_snippet: "",
    },
    {
    name: "Introspection",
    qualified_name: "Langkit_Support.Errors.Introspection",
    signature: "langkit_support.errors.introspection",
    enclosing: "langkit_support.errors",
    is_private: false,
    documentation: "",
    documentation_snippet: "",
    },
    {
    name: "Rewriting",
    qualified_name: "Langkit_Support.Errors.Rewriting",
    signature: "langkit_support.errors.rewriting",
    enclosing: "langkit_support.errors",
    is_private: false,
    documentation: "",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.File_Readers",
    qualified_name: "Langkit_Support.File_Readers",
    signature: "langkit_support.file_readers",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "This packages provides an interface to abstract away the action of reading\na source file to parse. Depending on use cases, it allows to override\nbytes-to-text decoding and preprocess sources (before actual\nlexing/parsing).",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Generic_API",
    qualified_name: "Langkit_Support.Generic_API",
    signature: "langkit_support.generic_api",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "----------------\n Language IDs --\n----------------",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Generic_API.Analysis",
    qualified_name: "Langkit_Support.Generic_API.Analysis",
    signature: "langkit_support.generic_api.analysis",
    enclosing: "langkit_support.generic_api",
    is_private: false,
    documentation: "This package provides a generic API so that programs can work with the\n$.Analysis packages of all Langkit-generated libraries.\n\nNote that it is experimental at this stage, and thus not officially\nsupported.\n\nTODO??? Create a language-agnostic documentation for all the concepts\nreferenced here (context, unit, node, token, trivia, ...).",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Generic_API.Introspection",
    qualified_name: "Langkit_Support.Generic_API.Introspection",
    signature: "langkit_support.generic_api.introspection",
    enclosing: "langkit_support.generic_api",
    is_private: false,
    documentation: "----------------------\n Polymorphic values --\n----------------------",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Generic_Bump_Ptr",
    qualified_name: "Langkit_Support.Generic_Bump_Ptr",
    signature: "langkit_support.generic_bump_ptr",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "-----------------------------------\n  Generic (and fast) ad-hoc pool --\n-----------------------------------\n\n@formal Page_Size\n  This constant has been chosen heuristically to be the lowest value that\n  gives the best performance. Bigger values did not make any difference,\n  and that way we ensure that pools can stay small.",
    documentation_snippet: "",
    },
    {
    name: "Alloc",
    qualified_name: "Langkit_Support.Generic_Bump_Ptr.Alloc",
    signature: "langkit_support.generic_bump_ptr.alloc",
    enclosing: "langkit_support.generic_bump_ptr",
    is_private: false,
    documentation: "",
    documentation_snippet: "",
    },
    {
    name: "Array_Alloc",
    qualified_name: "Langkit_Support.Generic_Bump_Ptr.Array_Alloc",
    signature: "langkit_support.generic_bump_ptr.array_alloc",
    enclosing: "langkit_support.generic_bump_ptr",
    is_private: false,
    documentation: "",
    documentation_snippet: "",
    },
    {
    name: "Tagged_Alloc",
    qualified_name: "Langkit_Support.Generic_Bump_Ptr.Tagged_Alloc",
    signature: "langkit_support.generic_bump_ptr.tagged_alloc",
    enclosing: "langkit_support.generic_bump_ptr",
    is_private: false,
    documentation: "",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Hashes",
    qualified_name: "Langkit_Support.Hashes",
    signature: "langkit_support.hashes",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Images",
    qualified_name: "Langkit_Support.Images",
    signature: "langkit_support.images",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "This package provides string formatting helpers related to 'Image attribute\nreferences.",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Internal",
    qualified_name: "Langkit_Support.Internal",
    signature: "langkit_support.internal",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Internal.Analysis",
    qualified_name: "Langkit_Support.Internal.Analysis",
    signature: "langkit_support.internal.analysis",
    enclosing: "langkit_support.internal",
    is_private: false,
    documentation: "Bare pointers to library-specific resources. For contexts, units and\nnodes, these correspond to the access types defined in $.Implementation.",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Internal.Conversions",
    qualified_name: "Langkit_Support.Internal.Conversions",
    signature: "langkit_support.internal.conversions",
    enclosing: "langkit_support.internal",
    is_private: false,
    documentation: "Conversions between public and internal types.\n\nThese converters need visibility over the implementation details of the\npublic types (for instance components of Lk_Node), but we do not want to\nexpose them in the Langkit_Support.Generic_API package tree: publish\nhere declarations as proxies to the implementations in\nLangkit_Support.Generic_API bodies.\n\nConverters for analysis contexts.  See the corresponding export\ndeclaration in Langkit_Support.Generic_API.Analysis.",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Internal.Descriptor",
    qualified_name: "Langkit_Support.Internal.Descriptor",
    signature: "langkit_support.internal.descriptor",
    enclosing: "langkit_support.internal",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Internal.Introspection",
    qualified_name: "Langkit_Support.Internal.Introspection",
    signature: "langkit_support.internal.introspection",
    enclosing: "langkit_support.internal",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Iterators",
    qualified_name: "Langkit_Support.Iterators",
    signature: "langkit_support.iterators",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "This generic package provides for each Element_Type an interface that\nused to implement iterators.\n\nBeyond the fact that it's super simple, the difference with standard\niterators is that iteration is destructive: once an element has been\nyielded, it's not possible to re-yield it once more.\n\nThe analogy with standard Ada containers is that there's no way to keep a\ncursor to preserve an iteration state.\n\n@formal Element_Type\n  Type for values produced at each iteration\n@formal Element_Array\n  Array type to use when consume the iterator into an array of elements",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Lexical_Envs",
    qualified_name: "Langkit_Support.Lexical_Envs",
    signature: "langkit_support.lexical_envs",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Lexical_Envs_Impl",
    qualified_name: "Langkit_Support.Lexical_Envs_Impl",
    signature: "langkit_support.lexical_envs_impl",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0\n\n@formal Get_Unit_Version\n  Used to retrieve the version number of the given Unit, for cache\n  invalidation purposes.\n@formal Node_Type\n@formal Node_Metadata\n@formal No_Node\n@formal Empty_Metadata\n@formal \"<\"\n@formal \"=\"\n@formal Ref_Category\n@formal Ref_Categories\n@formal Node_Unit\n@formal Node_Hash\n@formal Metadata_Hash\n@formal Combine\n@formal Can_Reach\n  Function that will allow filtering nodes depending on the origin node of\n  the request. In practice, this is used to implement sequential semantics\n  for lexical envs, as-in, node declared after another is not yet visible.\n@formal Is_Rebindable\n  Return whether a lexical environment whose node is Node can be rebound\n@formal Node_Text_Image\n@formal Acquire_Rebinding\n  Allocate if needed, initialize return a record to store env rebindings\n@formal Register_Rebinding\n  Register a rebinding to be destroyed when Node is destroyed\n@formal Get_Context_Version\n  Return the current version number of caches corresponding to Node's\n  context, for cache invalidation purposes.\n@formal Inner_Env_Assoc\n@formal Get_Key\n@formal Get_Node\n@formal Get_Metadata\n@formal Inner_Env_Assoc_Array\n@formal Length\n@formal Get\n@formal Dec_Ref\n@formal Properties_May_Raise",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Names",
    qualified_name: "Langkit_Support.Names",
    signature: "langkit_support.names",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Names.Maps",
    qualified_name: "Langkit_Support.Names.Maps",
    signature: "langkit_support.names.maps",
    enclosing: "langkit_support.names",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0\n\n@formal Element_Type",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Packrat",
    qualified_name: "Langkit_Support.Packrat",
    signature: "langkit_support.packrat",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "Those memo tables have a limited size, and use basic modulo to fit any\noffset in the limited size, so that an entry at index N will be put at\nindex N mod Memo_Size.\n\nIf there was already an entry at this spot, it will simply be removed.\nWhen querying for the entry at a given offset, we check whether there\nis an entry corresponding to Offset mod Memo_Size, and then if the entry\nexists, whether is corresponds to the same offset.\n\n@formal T\n@formal Token_Index\n@formal Memo_Size",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Slocs",
    qualified_name: "Langkit_Support.Slocs",
    signature: "langkit_support.slocs",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Symbols",
    qualified_name: "Langkit_Support.Symbols",
    signature: "langkit_support.symbols",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Symbols.Precomputed",
    qualified_name: "Langkit_Support.Symbols.Precomputed",
    signature: "langkit_support.symbols.precomputed",
    enclosing: "langkit_support.symbols",
    is_private: false,
    documentation: "\nCopyright (C) 2020-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0\n\n@formal Precomputed_Symbol_Index\n  Indexes for symbols to pre-compute in each symbol table\n@formal Precomputed_Symbol\n  Return the symbol corresponding to the precomputed symbol Index",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Text",
    qualified_name: "Langkit_Support.Text",
    signature: "langkit_support.text",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Chars",
    qualified_name: "Langkit_Support.Text.Chars",
    signature: "langkit_support.text.chars",
    enclosing: "langkit_support.text",
    is_private: false,
    documentation: "",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Token_Data_Handlers",
    qualified_name: "Langkit_Support.Token_Data_Handlers",
    signature: "langkit_support.token_data_handlers",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Tree_Traversal_Iterator",
    qualified_name: "Langkit_Support.Tree_Traversal_Iterator",
    signature: "langkit_support.tree_traversal_iterator",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0\n\n@formal Node_Type\n  Type for the node of trees to traverse\n@formal No_Node\n  Special value to represent the absence of a node\n@formal Node_Array\n  Type to use for array of nodes\n@formal First_Child_Index\n  Return the index of the first child in N\n@formal Last_Child_Index\n  Return the index of the last child in N\n@formal Get_Child\n  Return the Index-th child in N. Trees are allowed to have \"holes\" in\n  children, so Get_Child can return No_Node.\n@formal Get_Parent\n  Return the parent node for N. Returning No_Node means that N is the root\n  node.",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Types",
    qualified_name: "Langkit_Support.Types",
    signature: "langkit_support.types",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "Provide miscellaneous types to Langkit-generated libraries",
    documentation_snippet: "",
    },
    {
    name: "Langkit_Support.Vectors",
    qualified_name: "Langkit_Support.Vectors",
    signature: "langkit_support.vectors",
    enclosing: "langkit_support",
    is_private: false,
    documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0\n\n@formal Element_Type\n@formal Small_Vector_Capacity",
    documentation_snippet: "",
    },
]
}
---
