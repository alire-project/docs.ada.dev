---
crate: langkit_support
layout: gnatdoc
gnatdoc: {
name: "Langkit_Support.Lexical_Envs",
qualified_name: "Langkit_Support.Lexical_Envs",
signature: "langkit_support.lexical_envs",
enclosing: "langkit_support",
is_private: false,
documentation: "\nCopyright (C) 2014-2022, AdaCore\nSPDX-License-Identifier: Apache-2.0",
documentation_snippet: "",
simple_types:    [
       {
       name: "Generic_Unit_Ptr",
       qualified_name: "Langkit_Support.Lexical_Envs.Generic_Unit_Ptr",
       signature: "langkit_support.lexical_envs.generic_unit_ptr",
       enclosing: "",
       is_private: false,
       documentation: "Likewise for analysis units",
       documentation_snippet: "type Generic_Unit_Ptr is new System.Address;",
       }   ,
       {
       name: "Lexical_Env_Kind",
       qualified_name: "Langkit_Support.Lexical_Envs.Lexical_Env_Kind",
       signature: "langkit_support.lexical_envs.lexical_env_kind",
       enclosing: "",
       is_private: false,
       documentation: "Kind of lexical environment. Tells how a lexical environment was\ncreated.\n\nStatic_Primary ones are not ref-counted. Except for the special\nEmpty_Env and each context's root scope, they are created by lexical\nenvironment population.\n\nDynamic_Primary are not ref-counted neither. They are created on-demand\nduring semantic analysis, but their life cycle is tied to their owning\nanalysis unit, just like Static_Primary envs. They carry no map, but\ninstead use a property reference to dynamically compute environment\nassociations (an array of Inner_Env_Assoc).\n\nOrphaned ones are copies whose parents have been stripped.\n\nGrouped ones are just a collection of environments glued together as if\nthey were only one environment.\n\nRebound ones are copies annotated with environment rebindings.\n\n@enum Static_Primary\n@enum Dynamic_Primary\n@enum Orphaned\n@enum Grouped\n@enum Rebound",
       documentation_snippet: "type Lexical_Env_Kind is\n  (Static_Primary, Dynamic_Primary, Orphaned, Grouped, Rebound);",
       }   ,
       {
       name: "Lookup_Cache_Kind",
       qualified_name: "Langkit_Support.Lexical_Envs.Lookup_Cache_Kind",
       signature: "langkit_support.lexical_envs.lookup_cache_kind",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Lookup_Cache_Kind is (Disabled, Toplevel_Only, Full);",
       }   ,
       {
       name: "Lookup_Kind_Type",
       qualified_name: "Langkit_Support.Lexical_Envs.Lookup_Kind_Type",
       signature: "langkit_support.lexical_envs.lookup_kind_type",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Lookup_Kind_Type is (Recursive, Flat, Minimal);",
       }   ,
       {
       name: "Ref_Kind",
       qualified_name: "Langkit_Support.Lexical_Envs.Ref_Kind",
       signature: "langkit_support.lexical_envs.ref_kind",
       enclosing: "",
       is_private: false,
       documentation: "Kind for a referenced env. Can be any of:\n\n* Transitive: The reference is transitive, e.g. it will be explored in\n  every case (whether the lookup is recursive or not). It will be\n  explored *before* parent environments.\n\n* Prioritary: The reference is non transitive, e.g. it will be\n  explored only if the lookup on the env is recursive. It will be\n  explored *before* parent environments.\n\n* Normal: The reference is non transitive, e.g. it will be explored\n  only if the lookup on the env is recursive. It will be explored\n  *after* parent environments.\n\n@enum Transitive\n@enum Prioritary\n@enum Normal",
       documentation_snippet: "type Ref_Kind is (Transitive, Prioritary, Normal);",
       }   ,
       {
       name: "Refd_Env_State",
       qualified_name: "Langkit_Support.Lexical_Envs.Refd_Env_State",
       signature: "langkit_support.lexical_envs.refd_env_state",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Refd_Env_State is (Active, Inactive);",
       }   ,
   ]
,array_types:    [
       {
       name: "Lexical_Env_Array",
       qualified_name: "Langkit_Support.Lexical_Envs.Lexical_Env_Array",
       signature: "langkit_support.lexical_envs.lexical_env_array",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Lexical_Env_Array is array (Positive range <>) of Lexical_Env;",
       }   ,
   ]
,record_types:    [
       {
       name: "Base_Lexical_Env_Record",
       qualified_name: "Langkit_Support.Lexical_Envs.Base_Lexical_Env_Record",
       signature: "langkit_support.lexical_envs.base_lexical_env_record",
       enclosing: "",
       is_private: false,
       documentation: "Root class of the lexical env type for all languages",
       documentation_snippet: "type Base_Lexical_Env_Record is abstract tagged null record;",
       }   ,
       {
       name: "Env_Rebindings_Type",
       qualified_name: "Langkit_Support.Lexical_Envs.Env_Rebindings_Type",
       signature: "langkit_support.lexical_envs.env_rebindings_type",
       enclosing: "",
       is_private: false,
       documentation: "Tree of remappings from one lexical environment (Old_Env) to another\n(New_Env). Note that both referenced environments must be primary and\nenv rebindings are supposed to be destroyed when one of their\ndependencies (Parent, Old_Env or New_Env) is destroyed, so there is no\nneed for ref-counting primitives.\n\n@field Version\n  Allocated Env_Rebindings_Type records can be used multiple times\n  for a given analysis context. Each time we re-use one, we bump its\n  version number, so that we can reject the use of stale references.\n  End of ABI area\n@field Parent\n@field Old_Env\n@field New_Env\n@field Children",
       documentation_snippet: "type Env_Rebindings_Type is record\n   Version : Version_Number;\n   Parent           : Env_Rebindings;\n   Old_Env, New_Env : Lexical_Env;\n   Children         : Env_Rebindings_Vectors.Vector;\nend record\n   with Convention => C;",
       }   ,
       {
       name: "Lexical_Env",
       qualified_name: "Langkit_Support.Lexical_Envs.Lexical_Env",
       signature: "langkit_support.lexical_envs.lexical_env",
       enclosing: "",
       is_private: false,
       documentation: "Reference to a lexical environment. This is the type that shall be used.\n\n@field Env\n  Referenced lexical environment\n@field Hash\n  Env's hash. We need to pre-compute it so that the value is available\n  even after Env is deallocated. This makes it possible to destroy a\n  hash table that contains references to deallocated environments.\n@field Kind\n  The kind of Env. When it is Primary, we can avoid calling Dec_Ref at\n  destruction time. This is useful because at analysis unit destruction\n  time, this may be a dangling access to an environment from another\n  unit.\n@field Owner\n  Unit that owns this lexical environment. Only Primary and Rebound\n  lexical env will have a non-null value for this field.\n@field Version",
       documentation_snippet: "type Lexical_Env is record\n   Env : Generic_Lexical_Env_Ptr;\n   Hash : Hash_Type;\n   Kind : Lexical_Env_Kind;\n   Owner : Generic_Unit_Ptr := No_Generic_Unit;\n   Version : Version_Number := 0;\nend record;",
       }   ,
   ]
,access_types:    [
       {
       name: "Env_Rebindings",
       qualified_name: "Langkit_Support.Lexical_Envs.Env_Rebindings",
       signature: "langkit_support.lexical_envs.env_rebindings",
       enclosing: "",
       is_private: false,
       documentation: "Set of mappings from one lexical environment to another. This is used to\ntemporarily substitute lexical environment during symbol lookup.",
       documentation_snippet: "type Env_Rebindings is access all Env_Rebindings_Type;",
       }   ,
       {
       name: "Env_Rebindings_Pool",
       qualified_name: "Langkit_Support.Lexical_Envs.Env_Rebindings_Pool",
       signature: "langkit_support.lexical_envs.env_rebindings_pool",
       enclosing: "",
       is_private: false,
       documentation: "Pool of env rebindings to be stored in a lexical environment",
       documentation_snippet: "type Env_Rebindings_Pool is access all Env_Rebindings_Pools.Map;",
       }   ,
       {
       name: "Generic_Lexical_Env_Ptr",
       qualified_name: "Langkit_Support.Lexical_Envs.Generic_Lexical_Env_Ptr",
       signature: "langkit_support.lexical_envs.generic_lexical_env_ptr",
       enclosing: "",
       is_private: false,
       documentation: "Generic access to lexical environment records. The actual record type\ndepends on each language, hence the generic pointer.",
       documentation_snippet: "type Generic_Lexical_Env_Ptr is access all Base_Lexical_Env_Record'Class;",
       }   ,
       {
       name: "Lexical_Env_Array_Access",
       qualified_name: "Langkit_Support.Lexical_Envs.Lexical_Env_Array_Access",
       signature: "langkit_support.lexical_envs.lexical_env_array_access",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Lexical_Env_Array_Access is access all Lexical_Env_Array;",
       }   ,
   ]
,subtypes:    [
       {
       name: "Primary_Kind",
       qualified_name: "Langkit_Support.Lexical_Envs.Primary_Kind",
       signature: "langkit_support.lexical_envs.primary_kind",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype Primary_Kind is\n   Lexical_Env_Kind range Static_Primary ..  Dynamic_Primary;",
       }   ,
   ]
,constants:    [
       {
       name: "Caches_Trace",
       qualified_name: "Langkit_Support.Lexical_Envs.Caches_Trace",
       signature: "langkit_support.lexical_envs.caches_trace",
       enclosing: "",
       is_private: false,
       documentation: "This a trace to show caching information",
       documentation_snippet: "Caches_Trace : constant GNATCOLL.Traces.Trace_Handle :=\n   GNATCOLL.Traces.Create\n     (\"LANGKIT.LEXICAL_ENV.CACHES\", GNATCOLL.Traces.From_Config);",
       }   ,
       {
       name: "Me",
       qualified_name: "Langkit_Support.Lexical_Envs.Me",
       signature: "langkit_support.lexical_envs.me",
       enclosing: "",
       is_private: false,
       documentation: "This is the main trace for lexical environments, providing a basic level\nof logging for env.get requests.",
       documentation_snippet: "Me : constant GNATCOLL.Traces.Trace_Handle :=\n   GNATCOLL.Traces.Create\n     (\"LANGKIT.LEXICAL_ENV\", GNATCOLL.Traces.From_Config);",
       }   ,
       {
       name: "Min",
       qualified_name: "Langkit_Support.Lexical_Envs.Min",
       signature: "langkit_support.lexical_envs.min",
       enclosing: "",
       is_private: false,
       documentation: "This is a trace independent from the three last traces, that you can\nactivate separately, and that will provide you the most basic level of\nlogging for toplevel env.get requests.",
       documentation_snippet: "Min : constant GNATCOLL.Traces.Trace_Handle :=\n  GNATCOLL.Traces.Create\n    (\"LANGKIT.LEXICAL_ENV_MINIMAL\", GNATCOLL.Traces.From_Config);",
       }   ,
       {
       name: "No_Generic_Unit",
       qualified_name: "Langkit_Support.Lexical_Envs.No_Generic_Unit",
       signature: "langkit_support.lexical_envs.no_generic_unit",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "No_Generic_Unit : constant Generic_Unit_Ptr :=\n   Generic_Unit_Ptr (System.Null_Address);",
       }   ,
       {
       name: "No_Lexical_Env",
       qualified_name: "Langkit_Support.Lexical_Envs.No_Lexical_Env",
       signature: "langkit_support.lexical_envs.no_lexical_env",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "No_Lexical_Env : constant Generic_Lexical_Env_Ptr := null;",
       }   ,
       {
       name: "Null_Lexical_Env",
       qualified_name: "Langkit_Support.Lexical_Envs.Null_Lexical_Env",
       signature: "langkit_support.lexical_envs.null_lexical_env",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Null_Lexical_Env : constant Lexical_Env :=\n  (No_Lexical_Env, 0, Static_Primary, No_Generic_Unit, 0);",
       }   ,
       {
       name: "Rec",
       qualified_name: "Langkit_Support.Lexical_Envs.Rec",
       signature: "langkit_support.lexical_envs.rec",
       enclosing: "",
       is_private: false,
       documentation: "This is the recursive trace, providing info about recursive internal\ncalls to env.get.",
       documentation_snippet: "Rec : constant GNATCOLL.Traces.Trace_Handle :=\n   GNATCOLL.Traces.Create\n     (\"LANGKIT.LEXICAL_ENV.RECURSIVE\", GNATCOLL.Traces.From_Config);",
       }   ,
   ]
,variables:    [
       {
       name: "Lookup_Cache_Mode",
       qualified_name: "Langkit_Support.Lexical_Envs.Lookup_Cache_Mode",
       signature: "langkit_support.lexical_envs.lookup_cache_mode",
       enclosing: "",
       is_private: false,
       documentation: "Lookup cache mode for the lexical envs.\n\n``Full`` means that every env.get request, including intermediate ones\nhappening as part of a user requested env.get, will be cached.\n\n``Toplevel_Only`` means that only top level requests, directly requested\nby the user of the Lexical_Envs API, will be cached.\n\n``Disabled`` means no caching will happen.\n\nThis setting is for debugging: caching all requests is the normal mode\n(maximum optimization), and the other modes reduce the amount of caching\ndone (less optimization, thus taking longer to run) to ease the\ninvestigation of env caching bugs.",
       documentation_snippet: "Lookup_Cache_Mode : Lookup_Cache_Kind := Full;",
       }   ,
   ]
,}
---
