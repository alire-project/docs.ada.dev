---
crate: rewriters
layout: gnatdoc
gnatdoc: {
name: "Predefined_Rewriters_Prefer_Quantified_Expressions",
qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions",
signature: "predefined_rewriters_prefer_quantified_expressions",
enclosing: "",
is_private: false,
documentation: "",
documentation_snippet: "",
constants:    [
       {
       name: "Rewriter_For_All_Elements_All",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_All_Elements_All",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_all_elements_all",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_All_Elements_All :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"declare $S_Var : Boolean := true; begin \" &\n        \"for $S_E of $S_Elements loop \" &\n        \"if $S_Expr then $S_Var := false; end if; \" & \"end loop; \" &\n        \"$M_Stmts; end;\",\n        Block_Stmt_Rule),\n     Make_Pattern\n       (\"declare $S_Var : Boolean := \" &\n        \"(for all $S_E of $S_Elements => not ($S_Expr)); \" &\n        \"begin $M_Stmts; end;\",\n        Block_Stmt_Rule),\n     Make_Match_Accepter_Function_Access\n       (Accept_Expr_No_Side_Effects'Access));",
       }   ,
       {
       name: "Rewriter_For_All_Elements_And_Then",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_All_Elements_And_Then",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_all_elements_and_then",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_All_Elements_And_Then :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"for $S_E of $S_Elements loop \" &\n        \"$S_Var := $S_Var and then $S_Cond;\" & \"end loop;\",\n        Loop_Stmt_Rule),\n     Make_Pattern\n       (\"$S_Var := $S_Var and then \" &\n        \"(for all $S_E of $S_Elements => $S_Cond);\",\n        Stmt_Rule));",
       }   ,
       {
       name: "Rewriter_For_All_Elements_Exit",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_All_Elements_Exit",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_all_elements_exit",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_All_Elements_Exit :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"declare $S_Var : Boolean := true; begin \" &\n        \"for $S_E of $S_Elements loop \" &\n        \"if $S_Cond then $S_Var := false; exit; end if; \" & \"end loop; \"\n        & \"$M_Stmts; end;\",\n        Block_Stmt_Rule),\n     Make_Pattern\n       (\"declare $S_Var : Boolean := \" &\n        \"(for all $S_E of $S_Elements => not ($S_Cond)); \" &\n        \"begin $M_Stmts; end;\",\n        Block_Stmt_Rule));",
       }   ,
       {
       name: "Rewriter_For_All_Elements_Return",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_All_Elements_Return",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_all_elements_return",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_All_Elements_Return :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"for $S_E of $S_Elements \" &\n        \"loop if $S_Cond then return false; end if; end loop; \" &\n        \"return true;\",\n        Stmts_Rule),\n     Make_Pattern\n       (\"return (for all $S_E of $S_Elements => not ($S_Cond));\",\n        Return_Stmt_Rule));",
       }   ,
       {
       name: "Rewriter_For_All_Range_All",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_All_Range_All",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_all_range_all",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_All_Range_All :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"declare $S_Var : Boolean := true; begin \" &\n        \"for $S_I in $S_Range \" &\n        \"loop if $S_Expr then $S_Var := false; end if; end loop; \" &\n        \"$M_Stmts; end;\",\n        Block_Stmt_Rule),\n     Make_Pattern\n       (\"declare $S_Var : Boolean := \" &\n          \"(for all $S_I in $S_Range => not ($S_Expr)); \" &\n          \"begin $M_Stmts; end;\",\n        Block_Stmt_Rule),\n     Make_Match_Accepter_Function_Access\n       (Accept_Expr_No_Side_Effects'Access));",
       }   ,
       {
       name: "Rewriter_For_All_Range_And_Then",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_All_Range_And_Then",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_all_range_and_then",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_All_Range_And_Then :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"for $S_I in $S_Range \" &\n        \"loop $S_Var := $S_Var and then $S_Cond; end loop;\",\n        Loop_Stmt_Rule),\n     Make_Pattern\n     (\"$S_Var := $S_Var and then (for all $S_I in $S_Range => $S_Cond);\",\n      Stmt_Rule),\n     Make_Match_Accepter_Function_Access (Accept_Single_Variable'Access));",
       }   ,
       {
       name: "Rewriter_For_All_Range_Exit",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_All_Range_Exit",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_all_range_exit",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_All_Range_Exit :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"declare $S_Var : Boolean := true; begin \" &\n        \"for $S_I in $S_Range \" &\n        \"loop if $S_Cond then $S_Var := false; exit; end if; end loop; \"\n        & \"$M_Stmts; end;\",\n        Block_Stmt_Rule),\n     Make_Pattern\n       (\"declare $S_Var : Boolean := \" &\n          \"(for all $S_I in $S_Range => not ($S_Cond)); \" &\n          \"begin $M_Stmts; end;\",\n        Block_Stmt_Rule));",
       }   ,
       {
       name: "Rewriter_For_All_Range_Return",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_All_Range_Return",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_all_range_return",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_All_Range_Return :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"for $S_I in $S_Range \" &\n        \"loop if $S_Cond then return false; end if; end loop; \" &\n        \"return true;\",\n        Stmts_Rule),\n     Make_Pattern\n       (\"return (for all $S_I in $S_Range => not ($S_Cond));\",\n        Return_Stmt_Rule));",
       }   ,
       {
       name: "Rewriter_For_Some_Elements_All",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_Some_Elements_All",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_some_elements_all",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_Some_Elements_All :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"declare $S_Var : Boolean := false; begin \" &\n        \"for $S_E of $S_Elements loop \" &\n        \"if $S_Expr then $S_Var := true; end if; \" & \"end loop; \" &\n        \"$M_Stmts; end;\",\n        Block_Stmt_Rule),\n     Make_Pattern\n       (\"declare $S_Var : Boolean := \" &\n        \"(for some $S_E of $S_Elements => $S_Expr); \" &\n        \"begin $M_Stmts; end;\",\n        Block_Stmt_Rule),\n     Make_Match_Accepter_Function_Access\n       (Accept_Expr_No_Side_Effects'Access));",
       }   ,
       {
       name: "Rewriter_For_Some_Elements_Exit",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_Some_Elements_Exit",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_some_elements_exit",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_Some_Elements_Exit :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"declare $S_Var : Boolean := false; begin \" &\n        \"for $S_E of $S_Elements loop \" &\n        \"if $S_Cond then $S_Var := true; exit; end if; \" & \"end loop; \" &\n        \"$M_Stmts; end;\",\n        Block_Stmt_Rule),\n     Make_Pattern\n       (\"declare $S_Var : Boolean := \" &\n        \"(for some $S_E of $S_Elements => $S_Cond); \" &\n        \"begin $M_Stmts; end;\",\n        Block_Stmt_Rule));",
       }   ,
       {
       name: "Rewriter_For_Some_Elements_Or_Else",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_Some_Elements_Or_Else",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_some_elements_or_else",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_Some_Elements_Or_Else :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"for $S_E of $S_Elements loop \" &\n        \"$S_Var := $S_Var or else $S_Cond;\" & \"end loop;\",\n        Loop_Stmt_Rule),\n     Make_Pattern\n       (\"$S_Var := $S_Var or else \" &\n        \"(for some $S_E of $S_Elements => $S_Cond);\",\n        Stmt_Rule));",
       }   ,
       {
       name: "Rewriter_For_Some_Elements_Return",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_Some_Elements_Return",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_some_elements_return",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_Some_Elements_Return :\naliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"for $S_E of $S_Elements \" &\n        \"loop if $S_Cond then return true; end if; end loop; \" &\n        \"return false;\",\n        Stmts_Rule),\n     Make_Pattern\n       (\"return (for some $S_E of $S_Elements => $S_Cond);\",\n        Return_Stmt_Rule));",
       }   ,
       {
       name: "Rewriter_For_Some_Range_All",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_Some_Range_All",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_some_range_all",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_Some_Range_All :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"declare $S_Var : Boolean := false; begin \" &\n        \"for $S_I in $S_Range \" &\n        \"loop if $S_Expr then $S_Var := true; end if; end loop; \" &\n        \"$M_Stmts; end;\",\n        Block_Stmt_Rule),\n     Make_Pattern\n       (\"declare $S_Var : Boolean := \" &\n        \"(for some $S_I in $S_Range => $S_Expr); \"\n        & \"begin $M_Stmts; end;\",\n        Block_Stmt_Rule),\n     Make_Match_Accepter_Function_Access\n       (Accept_Expr_No_Side_Effects'Access));",
       }   ,
       {
       name: "Rewriter_For_Some_Range_Exit",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_Some_Range_Exit",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_some_range_exit",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_Some_Range_Exit :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"declare $S_Var : Boolean := false; begin \" &\n        \"for $S_I in $S_Range \" &\n        \"loop if $S_Cond then $S_Var := true; exit; end if; end loop; \" &\n        \"$M_Stmts; end;\",\n        Block_Stmt_Rule),\n     Make_Pattern\n       (\"declare $S_Var : Boolean := \" &\n        \"(for some $S_I in $S_Range => $S_Cond); \"\n         & \"begin $M_Stmts; end;\",\n        Block_Stmt_Rule));",
       }   ,
       {
       name: "Rewriter_For_Some_Range_Or_Else",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_Some_Range_Or_Else",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_some_range_or_else",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_Some_Range_Or_Else :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"for $S_I in $S_Range \" &\n        \"loop $S_Var := $S_Var or else $S_Cond; end loop;\",\n        Loop_Stmt_Rule),\n     Make_Pattern\n     (\"$S_Var := $S_Var or else (for some $S_I in $S_Range => $S_Cond);\",\n      Stmt_Rule),\n     Make_Match_Accepter_Function_Access (Accept_Single_Variable'Access));",
       }   ,
       {
       name: "Rewriter_For_Some_Range_Return",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_For_Some_Range_Return",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_for_some_range_return",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_For_Some_Range_Return :\n  aliased constant Rewriter_Find_And_Replace :=\n  Make_Rewriter_Find_And_Replace\n    (Make_Pattern\n       (\"for $S_I in $S_Range \" &\n        \"loop if $S_Cond then return true; end if; end loop; \" &\n        \"return false;\",\n        Stmts_Rule),\n     Make_Pattern\n       (\"return (for some $S_I in $S_Range => $S_Cond);\",\n        Return_Stmt_Rule));",
       }   ,
       {
       name: "Rewriter_Quantified_Expressions",
       qualified_name: "Predefined_Rewriters_Prefer_Quantified_Expressions.Rewriter_Quantified_Expressions",
       signature: "predefined_rewriters_prefer_quantified_expressions.rewriter_quantified_expressions",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Rewriter_Quantified_Expressions :\naliased constant Rewriter_Sequence :=\n  Make_Rewriter_Sequence\n    (Rewriter_For_All_Range_And_Then &\n       Rewriter_For_All_Elements_And_Then &\n       Rewriter_For_Some_Range_Or_Else &\n       Rewriter_For_Some_Elements_Or_Else &\n       Rewriter_For_All_Range_Exit &\n       Rewriter_For_All_Elements_Exit &\n       Rewriter_For_Some_Range_Exit &\n       Rewriter_For_Some_Elements_Exit &\n       Rewriter_For_All_Range_Return &\n       Rewriter_For_All_Elements_Return &\n       Rewriter_For_Some_Range_Return &\n       Rewriter_For_Some_Elements_Return &\n       Rewriter_For_All_Range_All &\n       Rewriter_For_All_Elements_All &\n       Rewriter_For_Some_Range_All &\n       Rewriter_For_Some_Elements_All\n    );",
       }   ,
   ]
,}
---
