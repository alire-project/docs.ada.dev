---
crate: usb_embedded
layout: gnatdoc
gnatdoc: {
name: "USB",
qualified_name: "USB",
signature: "usb",
enclosing: "",
is_private: false,
documentation: "----------------------------------------------------------------------------\n                                                                          --\n                     Copyright (C) 2018-2021, AdaCore                     --\n                                                                          --\n  Redistribution and use in source and binary forms, with or without      --\n  modification, are permitted provided that the following conditions are  --\n  met:                                                                    --\n     1. Redistributions of source code must retain the above copyright    --\n        notice, this list of conditions and the following disclaimer.     --\n     2. Redistributions in binary form must reproduce the above copyright --\n        notice, this list of conditions and the following disclaimer in   --\n        the documentation and/or other materials provided with the        --\n        distribution.                                                     --\n     3. Neither the name of the copyright holder nor the names of its     --\n        contributors may be used to endorse or promote products derived   --\n        from this software without specific prior written permission.     --\n                                                                          --\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    --\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      --\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  --\n   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   --\n   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, --\n   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       --\n   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  --\n   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  --\n   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    --\n   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  --\n   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   --\n                                                                          --\n----------------------------------------------------------------------------",
documentation_snippet: "",
simple_types:    [
       {
       name: "Data_Phase_Transfer_Direction",
       qualified_name: "USB.Data_Phase_Transfer_Direction",
       signature: "usb.data_phase_transfer_direction",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Data_Phase_Transfer_Direction is (Host_To_Device,\n                                       Device_To_Host)\n  with Size => 1;",
       }   ,
       {
       name: "EP_Dir",
       qualified_name: "USB.EP_Dir",
       signature: "usb.ep_dir",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type EP_Dir is (EP_In, EP_Out);",
       }   ,
       {
       name: "EP_Type",
       qualified_name: "USB.EP_Type",
       signature: "usb.ep_type",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type EP_Type is (Control, Isochronous, Bulk, Interrupt);",
       }   ,
       {
       name: "Interface_Id",
       qualified_name: "USB.Interface_Id",
       signature: "usb.interface_id",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Interface_Id is new UInt8;",
       }   ,
       {
       name: "Lang_ID",
       qualified_name: "USB.Lang_ID",
       signature: "usb.lang_id",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Lang_ID is new UInt16;",
       }   ,
       {
       name: "Packet_Size",
       qualified_name: "USB.Packet_Size",
       signature: "usb.packet_size",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Packet_Size is range 0 .. 1024;",
       }   ,
       {
       name: "Request_Type_Recipient",
       qualified_name: "USB.Request_Type_Recipient",
       signature: "usb.request_type_recipient",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Request_Type_Recipient is (Dev, Iface, Endpoint, Other);",
       }   ,
       {
       name: "Request_Type_Type",
       qualified_name: "USB.Request_Type_Type",
       signature: "usb.request_type_type",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Request_Type_Type is (Stand, Class, Vendor, Reserved)\n  with Size => 2;",
       }   ,
       {
       name: "Setup_Request_Answer",
       qualified_name: "USB.Setup_Request_Answer",
       signature: "usb.setup_request_answer",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Setup_Request_Answer is (Handled, Not_Supported, Next_Callback);",
       }   ,
       {
       name: "String_Id",
       qualified_name: "USB.String_Id",
       signature: "usb.string_id",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type String_Id is new UInt8;",
       }   ,
   ]
,array_types:    [
       {
       name: "USB_String",
       qualified_name: "USB.USB_String",
       signature: "usb.usb_string",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type USB_String is array (String_Range range <>) of Character;",
       }   ,
   ]
,record_types:    [
       {
       name: "Device_Descriptor",
       qualified_name: "USB.Device_Descriptor",
       signature: "usb.device_descriptor",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Device_Descriptor is record\n   bLength            : UInt8;\n   bDescriptorType    : UInt8;\n   bcdUSB             : UInt16;\n   bDeviceClass       : UInt8;\n   bDeviceSubClass    : UInt8;\n   bDeviceProtocol    : UInt8;\n   bMaxPacketSize0    : UInt8;\n   idVendor           : UInt16;\n   idProduct          : UInt16;\n   bcdDevice          : UInt16;\n   iManufacturer      : String_Id;\n   iProduct           : String_Id;\n   iSerialNumber      : String_Id;\n   bNumConfigurations : UInt8;\nend record with Pack;",
       }   ,
       {
       name: "Device_Qualifier",
       qualified_name: "USB.Device_Qualifier",
       signature: "usb.device_qualifier",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Device_Qualifier is record\n   bLength            : UInt8;\n   bDescriptorType    : UInt8;\n   bcdUSB             : UInt16;\n   bDeviceClass       : UInt8;\n   bDeviceSubClass    : UInt8;\n   bDeviceProtocol    : UInt8;\n   bMaxPacketSize0    : UInt8;\n   bNumConfigurations : UInt8;\n   bReserved          : UInt8;\nend record with Pack;",
       }   ,
       {
       name: "EP_Addr",
       qualified_name: "USB.EP_Addr",
       signature: "usb.ep_addr",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type EP_Addr is record\n   Num : EP_Id;\n   Dir : EP_Dir;\nend record;",
       }   ,
       {
       name: "Request_Type",
       qualified_name: "USB.Request_Type",
       signature: "usb.request_type",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Request_Type is record\n   Recipient : Request_Type_Recipient;\n   Reserved  : UInt3;\n   Typ : Request_Type_Type;\n   Dir : Data_Phase_Transfer_Direction;\nend record with Pack, Size => 8;",
       }   ,
       {
       name: "Setup_Data",
       qualified_name: "USB.Setup_Data",
       signature: "usb.setup_data",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Setup_Data is record\n   RType   : Request_Type;\n   Request : UInt8;\n   Value   : UInt16;\n   Index   : UInt16;\n   Length  : UInt16;\nend record with Pack, Size => 8 * 8;",
       }   ,
       {
       name: "String_Descriptor",
       qualified_name: "USB.String_Descriptor",
       signature: "usb.string_descriptor",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type String_Descriptor (bLength : UInt8) is record\n   bDescriptorType    : UInt8 := 3;\n   Str                : USB_String (3 .. bLength);\nend record with Pack;",
       }   ,
       {
       name: "String_Descriptor_Zero",
       qualified_name: "USB.String_Descriptor_Zero",
       signature: "usb.string_descriptor_zero",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type String_Descriptor_Zero is record\n   bLength            : UInt8;\n   bDescriptorType    : UInt8 := 3;\n   Str                : String (1 .. 2);\nend record;",
       }   ,
   ]
,subtypes:    [
       {
       name: "Buffer_Len",
       qualified_name: "USB.Buffer_Len",
       signature: "usb.buffer_len",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype Buffer_Len is System.Storage_Elements.Storage_Offset;",
       }   ,
       {
       name: "Control_Packet_Size",
       qualified_name: "USB.Control_Packet_Size",
       signature: "usb.control_packet_size",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype Control_Packet_Size is Packet_Size range 0 .. 64;",
       }   ,
       {
       name: "EP_Id",
       qualified_name: "USB.EP_Id",
       signature: "usb.ep_id",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype EP_Id is UInt4;",
       }   ,
       {
       name: "String_Range",
       qualified_name: "USB.String_Range",
       signature: "usb.string_range",
       enclosing: "",
       is_private: false,
       documentation: "The maximum length of a string is limited by the the bLength field of\nthe String Descriptor. This field is one byte: 0 .. 255, but bLength\nencodes to total size of the descriptor including the bLenght and\nbDescriptorType fields (one byte each). So the remaining length for\nstring is 255 - 2.",
       documentation_snippet: "subtype String_Range is UInt8 range 0 .. 253;",
       }   ,
   ]
,constants:    [
       {
       name: "Control_Buffer_Size",
       qualified_name: "USB.Control_Buffer_Size",
       signature: "usb.control_buffer_size",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Control_Buffer_Size : constant := Usb_Embedded_Config.Control_Buffer_Size;",
       }   ,
       {
       name: "Invalid_String_Id",
       qualified_name: "USB.Invalid_String_Id",
       signature: "usb.invalid_string_id",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Invalid_String_Id : constant String_Id := 0;",
       }   ,
       {
       name: "Max_Strings",
       qualified_name: "USB.Max_Strings",
       signature: "usb.max_strings",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Max_Strings : constant := Usb_Embedded_Config.Max_Strings;",
       }   ,
       {
       name: "Max_Total_String_Chars",
       qualified_name: "USB.Max_Total_String_Chars",
       signature: "usb.max_total_string_chars",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Max_Total_String_Chars : constant := Usb_Embedded_Config.String_Buffer_Size;",
       }   ,
       {
       name: "Verbose",
       qualified_name: "USB.Verbose",
       signature: "usb.verbose",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "Verbose : constant Boolean := False;",
       }   ,
   ]
,}
---
