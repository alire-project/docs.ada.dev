---
crate: littlefs
layout: gnatdoc
gnatdoc: {
name: "Littlefs",
qualified_name: "Littlefs",
signature: "littlefs",
enclosing: "",
is_private: false,
documentation: "",
documentation_snippet: "",
simple_types:    [
       {
       name: "Entry_Info",
       qualified_name: "Littlefs.Entry_Info",
       signature: "littlefs.entry_info",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type Entry_Info is private;",
       }   ,
       {
       name: "File_Kind",
       qualified_name: "Littlefs.File_Kind",
       signature: "littlefs.file_kind",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type File_Kind is (Register, Directory);",
       }   ,
       {
       name: "LFS_Dir",
       qualified_name: "Littlefs.LFS_Dir",
       signature: "littlefs.lfs_dir",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type LFS_Dir is private;",
       }   ,
       {
       name: "LFS_File",
       qualified_name: "Littlefs.LFS_File",
       signature: "littlefs.lfs_file",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type LFS_File is private;",
       }   ,
       {
       name: "LFS_T",
       qualified_name: "Littlefs.LFS_T",
       signature: "littlefs.lfs_t",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "type LFS_T is private;",
       }   ,
       {
       name: "LFS_Whence_Flags",
       qualified_name: "Littlefs.LFS_Whence_Flags",
       signature: "littlefs.lfs_whence_flags",
       enclosing: "",
       is_private: false,
       documentation: "\n@enum LFS_SEEK_SET\n  Seek relative to an absolute position\n@enum LFS_SEEK_CUR\n  Seek relative to the current file position\n@enum LFS_SEEK_END\n  Seek relative to the end of the file",
       documentation_snippet: "type LFS_Whence_Flags is\n  (LFS_SEEK_SET,\n   LFS_SEEK_CUR,\n   LFS_SEEK_END)\nwith Convention => C;",
       }   ,
   ]
,record_types:    [
       {
       name: "lfs_attr",
       qualified_name: "Littlefs.lfs_attr",
       signature: "littlefs.lfs_attr",
       enclosing: "",
       is_private: false,
       documentation: "\n@field Id\n  8-bit type of attribute, provided by user and used to identify the\n  attribute\n@field Buffer\n  Pointer to buffer containing the attribute\n@field Size",
       documentation_snippet: "type lfs_attr is record\n   Id : aliased Interfaces.Unsigned_8;\n   Buffer : System.Address;\n   Size : aliased LFS_Size;\nend record\nwith Convention => C_Pass_By_Copy;",
       }   ,
       {
       name: "LFS_Config",
       qualified_name: "Littlefs.LFS_Config",
       signature: "littlefs.lfs_config",
       enclosing: "",
       is_private: false,
       documentation: "\n@field Context\n  Opaque user provided context that can be used to pass information to\n  the block device operations\n@field Read\n  Read a region in a block. Negative error codes are propogated to the\n  user.\n@field Prog\n  Program a region in a block. The block must have previously been\n  erased. Negative error codes are propogated to the user. May return\n  LFS_ERR_CORRUPT if the block should be considered bad.\n@field Erase\n  Erase a block. A block must be erased before being programmed. The\n  state of an erased block is undefined. Negative error codes are\n  propogated to the user. May return LFS_ERR_CORRUPT if the block\n  should be considered bad.\n@field Sync\n  Sync the state of the underlying block device. Negative error codes\n  are propogated to the user.\n  LFS_THREADSAFE not implemented\n  Lock the underlying block device. Negative error codes\n  are propogated to the user.\n  Unlock the underlying block device. Negative error codes\n  are propogated to the user.\n@field Read_Size\n  Minimum size of a block read. All read operations will be a multiple\n  of this value.\n@field Prog_Size\n  Minimum size of a block program. All program operations will be a\n  multiple of this value.\n@field Block_Size\n  Size of an erasable block. This does not impact ram consumption and\n  may be larger than the physical erase size. However, non-inlined\n  files take up at minimum one block. Must be a multiple of the read\n  and program sizes.\n@field Block_Count\n  Number of erasable blocks on the device.\n@field Block_Cycles\n  Number of erase cycles before littlefs evicts metadata logs and moves\n  the metadata to another block. Suggested values are in the range\n  100-1000, with large values having better performance at the cost\n  of less consistent wear distribution.\n  \n  Set to -1 to disable block-level wear-leveling.\n@field Cache_Size\n  Size of block caches. Each cache buffers a portion of a block in RAM.\n  The littlefs needs a read cache, a program cache, and one additional\n  cache per file. Larger caches can improve performance by storing more\n  data and reducing the number of disk accesses. Must be a multiple of\n  the read and program sizes, and a factor of the block size.\n@field Lookahead_Size\n  Size of the lookahead buffer in bytes. A larger lookahead buffer\n  increases the number of blocks found during an allocation pass. The\n  lookahead buffer is stored as a compact bitmap, so each byte of RAM\n  can track 8 blocks. Must be a multiple of 8.\n@field Read_Buffer\n  Optional statically allocated read buffer. Must be cache_size. By\n  default lfs_malloc is used to allocate this buffer.\n@field Prog_Buffer\n  Optional statically allocated program buffer. Must be cache_size. By\n  default lfs_malloc is used to allocate this buffer.\n@field Lookahead_Buffer\n  Optional statically allocated lookahead buffer. Must be\n  lookahead_size and aligned to a 32-bit boundary. By default\n  lfs_malloc is used to allocate this buffer.\n@field Name_Max\n  Optional upper limit on length of file names in bytes. No downside\n  for larger names except the size of the info struct which is\n  controlled by the LFS_NAME_MAX define. Defaults to LFS_NAME_MAX when\n  zero. Stored in superblock and must be respected by other littlefs\n  drivers.\n@field File_Max\n  Optional upper limit on files in bytes. No downside for larger files\n  but must be <= LFS_FILE_MAX. Defaults to LFS_FILE_MAX when zero.\n  Stored in superblock and must be respected by other littlefs drivers.\n@field Attr_Max",
       documentation_snippet: "type LFS_Config is record\n   Context : System.Address := System.Null_Address;\n   Read : access function (C : access constant LFS_Config;\n                           Block : LFS_Block;\n                           Off : LFS_Offset;\n                           Buffer : System.Address;\n                           Size : LFS_Size)\n                           return int := null;\n   Prog : access function (C : access constant LFS_Config;\n                           Block : LFS_Block;\n                           Off : LFS_Offset;\n                           Buffer : System.Address;\n                           Size : LFS_Size)\n                           return int := null;\n   Erase : access function (C : access constant LFS_Config;\n                            Block : LFS_Block)\n                            return int := null;\n   Sync : access function (C : access constant LFS_Config) return int :=\n     null;\n   Read_Size : aliased LFS_Size := 0;\n   Prog_Size : aliased LFS_Size := 0;\n   Block_Size : aliased LFS_Size := 0;\n   Block_Count : aliased LFS_Size := 0;\n   Block_Cycles : aliased Interfaces.Integer_32 := 0;\n   Cache_Size : aliased LFS_Size := 0;\n   Lookahead_Size : aliased LFS_Size := 0;\n   Read_Buffer : System.Address := System.Null_Address;\n   Prog_Buffer : System.Address := System.Null_Address;\n   Lookahead_Buffer : System.Address := System.Null_Address;\n   Name_Max : aliased LFS_Size := 0;\n   File_Max : aliased LFS_Size := 0;\n   Attr_Max : aliased LFS_Size := 0;\nend record\nwith Convention => C_Pass_By_Copy;",
       }   ,
       {
       name: "lfs_file_config",
       qualified_name: "Littlefs.lfs_file_config",
       signature: "littlefs.lfs_file_config",
       enclosing: "",
       is_private: false,
       documentation: "\n@field Buffer\n  Optional statically allocated file buffer. Must be cache_size.\n  By default lfs_malloc is used to allocate this buffer.\n@field Attrs\n  Optional list of custom attributes related to the file. If the file\n  is opened with read access, these attributes will be read from disk\n  during the open call. If the file is opened with write access, the\n  attributes will be written to disk every file sync or close. This\n  write occurs atomically with update to the file's contents. Custom\n  attributes are uniquely identified by an 8-bit type and limited to\n  LFS_ATTR_MAX bytes. When read, if the stored attribute is smaller\n  than the buffer, it will be padded with zeros. If the stored\n  attribute is larger, then it will be silently truncated. If the\n  attribute is not found, it will be created implicitly.\n@field Attr_Count",
       documentation_snippet: "type lfs_file_config is record\n   Buffer : System.Address;\n   Attrs : access lfs_attr;\n   Attr_Count : aliased LFS_Size;\nend record\nwith Convention => C_Pass_By_Copy;",
       }   ,
   ]
,subtypes:    [
       {
       name: "LFS_Block",
       qualified_name: "Littlefs.LFS_Block",
       signature: "littlefs.lfs_block",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype LFS_Block is Interfaces.Unsigned_32;",
       }   ,
       {
       name: "LFS_Error",
       qualified_name: "Littlefs.LFS_Error",
       signature: "littlefs.lfs_error",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "subtype LFS_Error is Interfaces.C.int;",
       }   ,
       {
       name: "LFS_Offset",
       qualified_name: "Littlefs.LFS_Offset",
       signature: "littlefs.lfs_offset",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype LFS_Offset is Interfaces.Unsigned_32;",
       }   ,
       {
       name: "LFS_Open_Flags",
       qualified_name: "Littlefs.LFS_Open_Flags",
       signature: "littlefs.lfs_open_flags",
       enclosing: "",
       is_private: false,
       documentation: "Move to end of file on every write",
       documentation_snippet: "subtype LFS_Open_Flags is Interfaces.C.unsigned;",
       }   ,
       {
       name: "LFS_Signed_Offset",
       qualified_name: "Littlefs.LFS_Signed_Offset",
       signature: "littlefs.lfs_signed_offset",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype LFS_Signed_Offset is Interfaces.Integer_32;",
       }   ,
       {
       name: "LFS_Signed_Size",
       qualified_name: "Littlefs.LFS_Signed_Size",
       signature: "littlefs.lfs_signed_size",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype LFS_Signed_Size is Interfaces.Integer_32;",
       }   ,
       {
       name: "LFS_Size",
       qualified_name: "Littlefs.LFS_Size",
       signature: "littlefs.lfs_size",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype LFS_Size is Interfaces.Unsigned_32;",
       }   ,
   ]
,constants:    [
       {
       name: "DISK_VERSION",
       qualified_name: "Littlefs.DISK_VERSION",
       signature: "littlefs.disk_version",
       enclosing: "",
       is_private: false,
       documentation: "Version of On-disk data structures\nMajor (top-nibble), incremented on backwards incompatible changes\nMinor (bottom-nibble), incremented on feature additions",
       documentation_snippet: "DISK_VERSION : constant := 16#00020000#;",
       }   ,
       {
       name: "LFS_ATTR_MAX",
       qualified_name: "Littlefs.LFS_ATTR_MAX",
       signature: "littlefs.lfs_attr_max",
       enclosing: "",
       is_private: false,
       documentation: "Maximum size of custom attributes in bytes, may be redefined, but there\nis no real benefit to using a smaller LFS_ATTR_MAX. Limited to <= 1022.\nPossible error codes, these are negative to allow valid positive return\nvalues",
       documentation_snippet: "LFS_ATTR_MAX : constant := Littlefs_Config.Max_Attr_Size;",
       }   ,
       {
       name: "LFS_ERR_BADF",
       qualified_name: "Littlefs.LFS_ERR_BADF",
       signature: "littlefs.lfs_err_badf",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_BADF        : constant LFS_Error := -9;",
       }   ,
       {
       name: "LFS_ERR_CORRUPT",
       qualified_name: "Littlefs.LFS_ERR_CORRUPT",
       signature: "littlefs.lfs_err_corrupt",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_CORRUPT     : constant LFS_Error := -84;",
       }   ,
       {
       name: "LFS_ERR_EXIST",
       qualified_name: "Littlefs.LFS_ERR_EXIST",
       signature: "littlefs.lfs_err_exist",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_EXIST       : constant LFS_Error := -17;",
       }   ,
       {
       name: "LFS_ERR_FBIG",
       qualified_name: "Littlefs.LFS_ERR_FBIG",
       signature: "littlefs.lfs_err_fbig",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_FBIG        : constant LFS_Error := -27;",
       }   ,
       {
       name: "LFS_ERR_INVAL",
       qualified_name: "Littlefs.LFS_ERR_INVAL",
       signature: "littlefs.lfs_err_inval",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_INVAL       : constant LFS_Error := -22;",
       }   ,
       {
       name: "LFS_ERR_IO",
       qualified_name: "Littlefs.LFS_ERR_IO",
       signature: "littlefs.lfs_err_io",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_IO          : constant LFS_Error := -5;",
       }   ,
       {
       name: "LFS_ERR_ISDIR",
       qualified_name: "Littlefs.LFS_ERR_ISDIR",
       signature: "littlefs.lfs_err_isdir",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_ISDIR       : constant LFS_Error := -21;",
       }   ,
       {
       name: "LFS_ERR_NAMETOOLONG",
       qualified_name: "Littlefs.LFS_ERR_NAMETOOLONG",
       signature: "littlefs.lfs_err_nametoolong",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_NAMETOOLONG : constant LFS_Error := -36;",
       }   ,
       {
       name: "LFS_ERR_NOATTR",
       qualified_name: "Littlefs.LFS_ERR_NOATTR",
       signature: "littlefs.lfs_err_noattr",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_NOATTR      : constant LFS_Error := -61;",
       }   ,
       {
       name: "LFS_ERR_NOENT",
       qualified_name: "Littlefs.LFS_ERR_NOENT",
       signature: "littlefs.lfs_err_noent",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_NOENT       : constant LFS_Error := -2;",
       }   ,
       {
       name: "LFS_ERR_NOMEM",
       qualified_name: "Littlefs.LFS_ERR_NOMEM",
       signature: "littlefs.lfs_err_nomem",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_NOMEM       : constant LFS_Error := -12;",
       }   ,
       {
       name: "LFS_ERR_NOSPC",
       qualified_name: "Littlefs.LFS_ERR_NOSPC",
       signature: "littlefs.lfs_err_nospc",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_NOSPC       : constant LFS_Error := -28;",
       }   ,
       {
       name: "LFS_ERR_NOTDIR",
       qualified_name: "Littlefs.LFS_ERR_NOTDIR",
       signature: "littlefs.lfs_err_notdir",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_NOTDIR      : constant LFS_Error := -20;",
       }   ,
       {
       name: "LFS_ERR_NOTEMPTY",
       qualified_name: "Littlefs.LFS_ERR_NOTEMPTY",
       signature: "littlefs.lfs_err_notempty",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_NOTEMPTY    : constant LFS_Error := -39;",
       }   ,
       {
       name: "LFS_ERR_OK",
       qualified_name: "Littlefs.LFS_ERR_OK",
       signature: "littlefs.lfs_err_ok",
       enclosing: "",
       is_private: false,
       documentation: "File name too long",
       documentation_snippet: "LFS_ERR_OK          : constant LFS_Error := 0;",
       }   ,
       {
       name: "LFS_FILE_MAX",
       qualified_name: "Littlefs.LFS_FILE_MAX",
       signature: "littlefs.lfs_file_max",
       enclosing: "",
       is_private: false,
       documentation: "Maximum size of a file in bytes, may be redefined to limit to support\nother drivers. Limited on disk to <= 4294967296. However, above\n2147483647 the functions lfs_file_seek, lfs_file_size, and lfs_file_tell\nwill return incorrect values due to using signed integers. Stored in\nsuperblock and must be respected by other littlefs drivers.",
       documentation_snippet: "LFS_FILE_MAX : constant := Littlefs_Config.Max_File_Size;",
       }   ,
       {
       name: "LFS_NAME_MAX",
       qualified_name: "Littlefs.LFS_NAME_MAX",
       signature: "littlefs.lfs_name_max",
       enclosing: "",
       is_private: false,
       documentation: "Maximum name size in bytes, may be redefined to reduce the size of\nthe info struct. Limited to <= 1022. Stored in superblock and must\nbe respected by other littlefs drivers.",
       documentation_snippet: "LFS_NAME_MAX : constant := Littlefs_Config.Max_Name_Size;",
       }   ,
       {
       name: "LFS_O_APPEND",
       qualified_name: "Littlefs.LFS_O_APPEND",
       signature: "littlefs.lfs_o_append",
       enclosing: "",
       is_private: false,
       documentation: "Move to end of file on every write",
       documentation_snippet: "LFS_O_APPEND  : constant LFS_Open_Flags := 16#000800#;",
       }   ,
       {
       name: "LFS_O_CREAT",
       qualified_name: "Littlefs.LFS_O_CREAT",
       signature: "littlefs.lfs_o_creat",
       enclosing: "",
       is_private: false,
       documentation: "Move to end of file on every write",
       documentation_snippet: "LFS_O_CREAT   : constant LFS_Open_Flags := 16#000100#;",
       }   ,
       {
       name: "LFS_O_EXCL",
       qualified_name: "Littlefs.LFS_O_EXCL",
       signature: "littlefs.lfs_o_excl",
       enclosing: "",
       is_private: false,
       documentation: "Move to end of file on every write",
       documentation_snippet: "LFS_O_EXCL    : constant LFS_Open_Flags := 16#000200#;",
       }   ,
       {
       name: "LFS_O_RDONLY",
       qualified_name: "Littlefs.LFS_O_RDONLY",
       signature: "littlefs.lfs_o_rdonly",
       enclosing: "",
       is_private: false,
       documentation: "Move to end of file on every write",
       documentation_snippet: "LFS_O_RDONLY  : constant LFS_Open_Flags := 16#000001#;",
       }   ,
       {
       name: "LFS_O_RDWR",
       qualified_name: "Littlefs.LFS_O_RDWR",
       signature: "littlefs.lfs_o_rdwr",
       enclosing: "",
       is_private: false,
       documentation: "Move to end of file on every write",
       documentation_snippet: "LFS_O_RDWR    : constant LFS_Open_Flags := 16#000003#;",
       }   ,
       {
       name: "LFS_O_TRUNC",
       qualified_name: "Littlefs.LFS_O_TRUNC",
       signature: "littlefs.lfs_o_trunc",
       enclosing: "",
       is_private: false,
       documentation: "Move to end of file on every write",
       documentation_snippet: "LFS_O_TRUNC   : constant LFS_Open_Flags := 16#000400#;",
       }   ,
       {
       name: "LFS_O_WRONLY",
       qualified_name: "Littlefs.LFS_O_WRONLY",
       signature: "littlefs.lfs_o_wronly",
       enclosing: "",
       is_private: false,
       documentation: "Move to end of file on every write",
       documentation_snippet: "LFS_O_WRONLY  : constant LFS_Open_Flags := 16#000002#;",
       }   ,
       {
       name: "VERSION",
       qualified_name: "Littlefs.VERSION",
       signature: "littlefs.version",
       enclosing: "",
       is_private: false,
       documentation: "Software library version\nMajor (top-nibble), incremented on backwards incompatible changes\nMinor (bottom-nibble), incremented on feature additions",
       documentation_snippet: "VERSION : constant := 16#00020003#;",
       }   ,
   ]
,}
---
