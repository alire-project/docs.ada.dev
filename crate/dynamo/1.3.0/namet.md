---
crate: dynamo
layout: gnatdoc
gnatdoc: {
name: "Namet",
qualified_name: "Namet",
signature: "namet",
enclosing: "",
is_private: false,
documentation: "WARNING: There is a C version of this package. Any changes to this\nsource file must be properly reflected in the C header file namet.h\nwhich is created manually from namet.ads and namet.adb.",
documentation_snippet: "",
simple_types:    [
       {
       name: "File_Name_Type",
       qualified_name: "Namet.File_Name_Type",
       signature: "namet.file_name_type",
       enclosing: "",
       is_private: false,
       documentation: "File names are stored in the names table and this type is used to\nindicate that a Name_Id value is being used to hold a simple file name\n(which does not include any directory information).",
       documentation_snippet: "type File_Name_Type is new Name_Id;",
       }   ,
       {
       name: "Name_Id",
       qualified_name: "Namet.Name_Id",
       signature: "namet.name_id",
       enclosing: "",
       is_private: false,
       documentation: "Type used to identify entries in the names table",
       documentation_snippet: "type Name_Id is range Names_Low_Bound .. Names_High_Bound;",
       }   ,
       {
       name: "Path_Name_Type",
       qualified_name: "Namet.Path_Name_Type",
       signature: "namet.path_name_type",
       enclosing: "",
       is_private: false,
       documentation: "Path names are stored in the names table and this type is used to\nindicate that a Name_Id value is being used to hold a path name (that\nmay contain directory information).",
       documentation_snippet: "type Path_Name_Type is new Name_Id;",
       }   ,
       {
       name: "Unit_Name_Type",
       qualified_name: "Namet.Unit_Name_Type",
       signature: "namet.unit_name_type",
       enclosing: "",
       is_private: false,
       documentation: "Unit names are stored in the names table and this type is used to\nindicate that a Name_Id value is being used to hold a unit name, which\nterminates in %b for a body or %s for a spec.",
       documentation_snippet: "type Unit_Name_Type is new Name_Id;",
       }   ,
   ]
,subtypes:    [
       {
       name: "Error_File_Name_Or_No_File",
       qualified_name: "Namet.Error_File_Name_Or_No_File",
       signature: "namet.error_file_name_or_no_file",
       enclosing: "",
       is_private: false,
       documentation: "Used to test for either error file name or no file",
       documentation_snippet: "subtype Error_File_Name_Or_No_File is\n  File_Name_Type range No_File .. Error_File_Name;",
       }   ,
       {
       name: "Error_Name_Or_No_Name",
       qualified_name: "Namet.Error_Name_Or_No_Name",
       signature: "namet.error_name_or_no_name",
       enclosing: "",
       is_private: false,
       documentation: "Used to test for either error name or no name",
       documentation_snippet: "subtype Error_Name_Or_No_Name is Name_Id range No_Name .. Error_Name;",
       }   ,
       {
       name: "Error_Unit_Name_Or_No_Unit_Name",
       qualified_name: "Namet.Error_Unit_Name_Or_No_Unit_Name",
       signature: "namet.error_unit_name_or_no_unit_name",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype Error_Unit_Name_Or_No_Unit_Name is\n  Unit_Name_Type range No_Unit_Name .. Error_Unit_Name;",
       }   ,
   ]
,constants:    [
       {
       name: "Error_File_Name",
       qualified_name: "Namet.Error_File_Name",
       signature: "namet.error_file_name",
       enclosing: "",
       is_private: false,
       documentation: "The special File_Name_Type value Error_File_Name is used to indicate\na unit name where some previous processing has found an error.",
       documentation_snippet: "Error_File_Name : constant File_Name_Type := File_Name_Type (Error_Name);",
       }   ,
       {
       name: "Error_Name",
       qualified_name: "Namet.Error_Name",
       signature: "namet.error_name",
       enclosing: "",
       is_private: false,
       documentation: "The special Name_Id value Error_Name is used in the parser to\nindicate that some kind of error was encountered in scanning out\nthe relevant name, so it does not have a representable label.",
       documentation_snippet: "Error_Name : constant Name_Id := Names_Low_Bound +  1;",
       }   ,
       {
       name: "Error_Unit_Name",
       qualified_name: "Namet.Error_Unit_Name",
       signature: "namet.error_unit_name",
       enclosing: "",
       is_private: false,
       documentation: "The special Unit_Name_Type value Error_Unit_Name is used to indicate\na unit name where some previous processing has found an error.",
       documentation_snippet: "Error_Unit_Name : constant Unit_Name_Type := Unit_Name_Type (Error_Name);",
       }   ,
       {
       name: "First_Name_Id",
       qualified_name: "Namet.First_Name_Id",
       signature: "namet.first_name_id",
       enclosing: "",
       is_private: false,
       documentation: "Subscript of first entry in names table",
       documentation_snippet: "First_Name_Id : constant Name_Id := Names_Low_Bound + 2;",
       }   ,
       {
       name: "No_File",
       qualified_name: "Namet.No_File",
       signature: "namet.no_file",
       enclosing: "",
       is_private: false,
       documentation: "Constant used to indicate no file is present (this is used for example\nwhen a search for a file indicates that no file of the name exists).",
       documentation_snippet: "No_File : constant File_Name_Type := File_Name_Type (No_Name);",
       }   ,
       {
       name: "No_Name",
       qualified_name: "Namet.No_Name",
       signature: "namet.no_name",
       enclosing: "",
       is_private: false,
       documentation: "The special Name_Id value No_Name is used in the parser to indicate\na situation where no name is present (e.g. on a loop or block).",
       documentation_snippet: "No_Name : constant Name_Id := Names_Low_Bound;",
       }   ,
       {
       name: "No_Path",
       qualified_name: "Namet.No_Path",
       signature: "namet.no_path",
       enclosing: "",
       is_private: false,
       documentation: "Constant used to indicate no path name is present",
       documentation_snippet: "No_Path : constant Path_Name_Type := Path_Name_Type (No_Name);",
       }   ,
       {
       name: "No_Unit_Name",
       qualified_name: "Namet.No_Unit_Name",
       signature: "namet.no_unit_name",
       enclosing: "",
       is_private: false,
       documentation: "Constant used to indicate no file name present",
       documentation_snippet: "No_Unit_Name : constant Unit_Name_Type := Unit_Name_Type (No_Name);",
       }   ,
   ]
,variables:    [
       {
       name: "Name_Buffer",
       qualified_name: "Namet.Name_Buffer",
       signature: "namet.name_buffer",
       enclosing: "",
       is_private: false,
       documentation: "This buffer is used to set the name to be stored in the table for the\nName_Find call, and to retrieve the name for the Get_Name_String call.\nThe limit here is intended to be an infinite value that ensures that we\nnever overflow the buffer (names this long are too absurd to worry).",
       documentation_snippet: "Name_Buffer : String (1 .. 4 * Max_Line_Length);",
       }   ,
       {
       name: "Name_Len",
       qualified_name: "Namet.Name_Len",
       signature: "namet.name_len",
       enclosing: "",
       is_private: false,
       documentation: "Length of name stored in Name_Buffer. Used as an input parameter for\nName_Find, and as an output value by Get_Name_String, or Write_Name.\nNote: in normal usage, all users of Name_Buffer/Name_Len are expected\nto initialize Name_Len appropriately. The reason we preinitialize to\nzero here is that some circuitry (e.g. Osint.Write_Program_Name) does\na save/restore on Name_Len and Name_Buffer (1 .. Name_Len), and we do\nnot want some arbitrary junk value to result in saving an arbitrarily\nlong slice which would waste time and blow the stack.",
       documentation_snippet: "Name_Len : Natural := 0;",
       }   ,
   ]
,}
---
