---
crate: dynamo
layout: gnatdoc
gnatdoc: {
name: "Scans",
qualified_name: "Scans",
signature: "scans",
enclosing: "",
is_private: false,
documentation: "The scanner maintains a current state in the global variables defined\nin this package. The call to the Scan routine advances this state to\nthe next token. The state is initialized by the call to one of the\ninitialization routines in Sinput.",
documentation_snippet: "",
simple_types:    [
       {
       name: "Saved_Scan_State",
       qualified_name: "Scans.Saved_Scan_State",
       signature: "scans.saved_scan_state",
       enclosing: "",
       is_private: false,
       documentation: "Used for saving and restoring the scan state",
       documentation_snippet: "type Saved_Scan_State is private;",
       }   ,
       {
       name: "Token_Type",
       qualified_name: "Scans.Token_Type",
       signature: "scans.token_type",
       enclosing: "",
       is_private: false,
       documentation: "\n@enum Tok_Integer_Literal\n  numeric lit  Literal, Lit_Or_Name\n@enum Tok_Real_Literal\n  numeric lit  Literal, Lit_Or_Name\n@enum Tok_String_Literal\n  string lit   Literal. Lit_Or_Name\n@enum Tok_Char_Literal\n  char lit     Name, Literal. Lit_Or_Name\n@enum Tok_Operator_Symbol\n  op symbol    Name, Literal, Lit_Or_Name, Desig\n@enum Tok_Identifier\n  identifier   Name, Lit_Or_Name, Desig\n@enum Tok_Double_Asterisk\n  **\n@enum Tok_Ampersand\n  &            Binary_Addop\n@enum Tok_Minus\n  -            Binary_Addop, Unary_Addop\n@enum Tok_Plus\n  +            Binary_Addop, Unary_Addop\n@enum Tok_Asterisk\n  *            Mulop\n@enum Tok_Mod\n  MOD          Mulop\n@enum Tok_Rem\n  REM          Mulop\n@enum Tok_Slash\n  /            Mulop\n@enum Tok_New\n  NEW\n@enum Tok_Abs\n  ABS\n   Note: Tok_Raise is in no categories now, it used to be Cterm, Eterm,\n   After_SM, but now that Ada 2012 has added raise expressions, the\n   raise token can appear anywhere. Note in particular that Tok_Raise\n   being in Eterm stopped the parser from recognizing \"return raise\n   exception-name\". This degrades error recovery slightly, and perhaps\n   we could do better, but not worth the effort.\n@enum Tok_Others\n  OTHERS\n   Note: Tok_Raise is in no categories now, it used to be Cterm, Eterm,\n   After_SM, but now that Ada 2012 has added raise expressions, the\n   raise token can appear anywhere. Note in particular that Tok_Raise\n   being in Eterm stopped the parser from recognizing \"return raise\n   exception-name\". This degrades error recovery slightly, and perhaps\n   we could do better, but not worth the effort.\n@enum Tok_Null\n  NULL\n   Note: Tok_Raise is in no categories now, it used to be Cterm, Eterm,\n   After_SM, but now that Ada 2012 has added raise expressions, the\n   raise token can appear anywhere. Note in particular that Tok_Raise\n   being in Eterm stopped the parser from recognizing \"return raise\n   exception-name\". This degrades error recovery slightly, and perhaps\n   we could do better, but not worth the effort.\n@enum Tok_Raise\n  RAISE\n@enum Tok_Dot\n  .            Namext\n@enum Tok_Apostrophe\n  '            Namext\n@enum Tok_Left_Paren\n  (            Namext, Consk\n@enum Tok_Delta\n  DELTA        Atkwd, Sterm, Consk\n@enum Tok_Digits\n  DIGITS       Atkwd, Sterm, Consk\n@enum Tok_Range\n  RANGE        Atkwd, Sterm, Consk\n@enum Tok_Right_Paren\n  )            Sterm\n@enum Tok_Comma\n  ,            Sterm\n@enum Tok_And\n  AND          Logop, Sterm\n@enum Tok_Or\n  OR           Logop, Sterm\n@enum Tok_Xor\n  XOR          Logop, Sterm\n@enum Tok_Less\n  <            Relop, Sterm\n@enum Tok_Equal\n  =            Relop, Sterm\n@enum Tok_Greater\n  >            Relop, Sterm\n@enum Tok_Not_Equal\n  /=           Relop, Sterm\n@enum Tok_Greater_Equal\n  >=           Relop, Sterm\n@enum Tok_Less_Equal\n  <=           Relop, Sterm\n@enum Tok_In\n  IN           Relop, Sterm\n@enum Tok_Not\n  NOT          Relop, Sterm\n@enum Tok_Box\n  <>           Relop, Eterm, Sterm\n@enum Tok_Colon_Equal\n  :=           Eterm, Sterm\n@enum Tok_Colon\n  :            Eterm, Sterm\n@enum Tok_Greater_Greater\n  >>           Eterm, Sterm\n@enum Tok_Abstract\n  ABSTRACT     Eterm, Sterm\n@enum Tok_Access\n  ACCESS       Eterm, Sterm\n@enum Tok_Aliased\n  ALIASED      Eterm, Sterm\n@enum Tok_All\n  ALL          Eterm, Sterm\n@enum Tok_Array\n  ARRAY        Eterm, Sterm\n@enum Tok_At\n  AT           Eterm, Sterm\n@enum Tok_Body\n  BODY         Eterm, Sterm\n@enum Tok_Constant\n  CONSTANT     Eterm, Sterm\n@enum Tok_Do\n  DO           Eterm, Sterm\n@enum Tok_Is\n  IS           Eterm, Sterm\n@enum Tok_Interface\n  INTERFACE    Eterm, Sterm\n@enum Tok_Limited\n  LIMITED      Eterm, Sterm\n@enum Tok_Of\n  OF           Eterm, Sterm\n@enum Tok_Out\n  OUT          Eterm, Sterm\n@enum Tok_Record\n  RECORD       Eterm, Sterm\n@enum Tok_Renames\n  RENAMES      Eterm, Sterm\n@enum Tok_Reverse\n  REVERSE      Eterm, Sterm\n@enum Tok_Some\n  SOME         Eterm, Sterm\n@enum Tok_Tagged\n  TAGGED       Eterm, Sterm\n@enum Tok_Then\n  THEN         Eterm, Sterm\n@enum Tok_Less_Less\n  <<           Eterm, Sterm, After_SM\n@enum Tok_Abort\n  ABORT        Eterm, Sterm, After_SM\n@enum Tok_Accept\n  ACCEPT       Eterm, Sterm, After_SM\n@enum Tok_Case\n  CASE         Eterm, Sterm, After_SM\n@enum Tok_Delay\n  DELAY        Eterm, Sterm, After_SM\n@enum Tok_Else\n  ELSE         Eterm, Sterm, After_SM\n@enum Tok_Elsif\n  ELSIF        Eterm, Sterm, After_SM\n@enum Tok_End\n  END          Eterm, Sterm, After_SM\n@enum Tok_Exception\n  EXCEPTION    Eterm, Sterm, After_SM\n@enum Tok_Exit\n  EXIT         Eterm, Sterm, After_SM\n@enum Tok_Goto\n  GOTO         Eterm, Sterm, After_SM\n@enum Tok_If\n  IF           Eterm, Sterm, After_SM\n@enum Tok_Pragma\n  PRAGMA       Eterm, Sterm, After_SM\n@enum Tok_Requeue\n  REQUEUE      Eterm, Sterm, After_SM\n@enum Tok_Return\n  RETURN       Eterm, Sterm, After_SM\n@enum Tok_Select\n  SELECT       Eterm, Sterm, After_SM\n@enum Tok_Terminate\n  TERMINATE    Eterm, Sterm, After_SM\n@enum Tok_Until\n  UNTIL        Eterm, Sterm, After_SM\n@enum Tok_When\n  WHEN         Eterm, Sterm, After_SM\n@enum Tok_Begin\n  BEGIN        Eterm, Sterm, After_SM, Labeled_Stmt\n@enum Tok_Declare\n  DECLARE      Eterm, Sterm, After_SM, Labeled_Stmt\n@enum Tok_For\n  FOR          Eterm, Sterm, After_SM, Labeled_Stmt\n@enum Tok_Loop\n  LOOP         Eterm, Sterm, After_SM, Labeled_Stmt\n@enum Tok_While\n  WHILE        Eterm, Sterm, After_SM, Labeled_Stmt\n@enum Tok_Entry\n  ENTRY        Eterm, Sterm, Declk, Deckn, After_SM\n@enum Tok_Protected\n  PROTECTED    Eterm, Sterm, Declk, Deckn, After_SM\n@enum Tok_Task\n  TASK         Eterm, Sterm, Declk, Deckn, After_SM\n@enum Tok_Type\n  TYPE         Eterm, Sterm, Declk, Deckn, After_SM\n@enum Tok_Subtype\n  SUBTYPE      Eterm, Sterm, Declk, Deckn, After_SM\n@enum Tok_Overriding\n  OVERRIDING   Eterm, Sterm, Declk, Declk, After_SM\n@enum Tok_Synchronized\n  SYNCHRONIZED Eterm, Sterm, Declk, Deckn, After_SM\n@enum Tok_Use\n  USE          Eterm, Sterm, Declk, Deckn, After_SM\n@enum Tok_Function\n  FUNCTION     Eterm, Sterm, Cunit, Declk, After_SM\n@enum Tok_Generic\n  GENERIC      Eterm, Sterm, Cunit, Declk, After_SM\n@enum Tok_Package\n  PACKAGE      Eterm, Sterm, Cunit, Declk, After_SM\n@enum Tok_Procedure\n  PROCEDURE    Eterm, Sterm, Cunit, Declk, After_SM\n@enum Tok_Private\n  PRIVATE      Eterm, Sterm, Cunit, After_SM\n@enum Tok_With\n  WITH         Eterm, Sterm, Cunit, After_SM\n@enum Tok_Separate\n  SEPARATE     Eterm, Sterm, Cunit, After_SM\n@enum Tok_EOF\n  End of file  Eterm, Sterm, Cterm, After_SM\n@enum Tok_Semicolon\n  ;            Eterm, Sterm, Cterm\n@enum Tok_Arrow\n  =>           Sterm, Cterm, Chtok\n@enum Tok_Vertical_Bar\n  |            Cterm, Sterm, Chtok\n@enum Tok_Dot_Dot\n  ..           Sterm, Chtok\n@enum Tok_Project\n  These four entries represent keywords for the project file language\n  and can be returned only in the case of scanning project files.\n@enum Tok_Extends\n  These four entries represent keywords for the project file language\n  and can be returned only in the case of scanning project files.\n@enum Tok_External\n  These four entries represent keywords for the project file language\n  and can be returned only in the case of scanning project files.\n@enum Tok_External_As_List\n  These four entries represent keywords for the project file language\n  and can be returned only in the case of scanning project files.\n@enum Tok_Comment\n  This entry is used when scanning project files (where it represents\n  an entire comment), and in preprocessing with the -C switch set\n  (where it represents just the \"--\" of a comment). For the project\n  file case, the text of the comment is stored in Comment_Id.\n@enum Tok_End_Of_Line\n  Represents an end of line. Not used during normal compilation scans\n  where end of line is ignored. Active for preprocessor scanning and\n  also when scanning project files (where it is needed because of ???)\n@enum Tok_Special\n  Used only in preprocessor scanning (to represent one of the\n  characters '#', '$', '?', '@', '`', '\\', '^', '~', or '_'. The\n  character value itself is stored in Scans.Special_Character.\n@enum Tok_SPARK_Hide\n  HIDE directive in SPARK\n@enum No_Token\n  No_Token is used for initializing Token values to indicate that\n  no value has been set yet.",
       documentation_snippet: "type Token_Type is (\n   Tok_Integer_Literal,\n   Tok_Real_Literal,\n   Tok_String_Literal,\n   Tok_Char_Literal,\n   Tok_Operator_Symbol,\n   Tok_Identifier,\n   Tok_Double_Asterisk,\n   Tok_Ampersand,\n   Tok_Minus,\n   Tok_Plus,\n   Tok_Asterisk,\n   Tok_Mod,\n   Tok_Rem,\n   Tok_Slash,\n   Tok_New,\n   Tok_Abs,\n   Tok_Others,\n   Tok_Null,\n   Tok_Raise,\n   Tok_Dot,\n   Tok_Apostrophe,\n   Tok_Left_Paren,\n   Tok_Delta,\n   Tok_Digits,\n   Tok_Range,\n   Tok_Right_Paren,\n   Tok_Comma,\n   Tok_And,\n   Tok_Or,\n   Tok_Xor,\n   Tok_Less,\n   Tok_Equal,\n   Tok_Greater,\n   Tok_Not_Equal,\n   Tok_Greater_Equal,\n   Tok_Less_Equal,\n   Tok_In,\n   Tok_Not,\n   Tok_Box,\n   Tok_Colon_Equal,\n   Tok_Colon,\n   Tok_Greater_Greater,\n   Tok_Abstract,\n   Tok_Access,\n   Tok_Aliased,\n   Tok_All,\n   Tok_Array,\n   Tok_At,\n   Tok_Body,\n   Tok_Constant,\n   Tok_Do,\n   Tok_Is,\n   Tok_Interface,\n   Tok_Limited,\n   Tok_Of,\n   Tok_Out,\n   Tok_Record,\n   Tok_Renames,\n   Tok_Reverse,\n   Tok_Some,\n   Tok_Tagged,\n   Tok_Then,\n   Tok_Less_Less,\n   Tok_Abort,\n   Tok_Accept,\n   Tok_Case,\n   Tok_Delay,\n   Tok_Else,\n   Tok_Elsif,\n   Tok_End,\n   Tok_Exception,\n   Tok_Exit,\n   Tok_Goto,\n   Tok_If,\n   Tok_Pragma,\n   Tok_Requeue,\n   Tok_Return,\n   Tok_Select,\n   Tok_Terminate,\n   Tok_Until,\n   Tok_When,\n   Tok_Begin,\n   Tok_Declare,\n   Tok_For,\n   Tok_Loop,\n   Tok_While,\n   Tok_Entry,\n   Tok_Protected,\n   Tok_Task,\n   Tok_Type,\n   Tok_Subtype,\n   Tok_Overriding,\n   Tok_Synchronized,\n   Tok_Use,\n   Tok_Function,\n   Tok_Generic,\n   Tok_Package,\n   Tok_Procedure,\n   Tok_Private,\n   Tok_With,\n   Tok_Separate,\n   Tok_EOF,\n   Tok_Semicolon,\n   Tok_Arrow,\n   Tok_Vertical_Bar,\n   Tok_Dot_Dot,\n   Tok_Project,\n   Tok_Extends,\n   Tok_External,\n   Tok_External_As_List,\n   Tok_Comment,\n   Tok_End_Of_Line,\n   Tok_Special,\n   Tok_SPARK_Hide,\n   No_Token);",
       }   ,
   ]
,array_types:    [
       {
       name: "Token_Flag_Array",
       qualified_name: "Scans.Token_Flag_Array",
       signature: "scans.token_flag_array",
       enclosing: "",
       is_private: false,
       documentation: "Flag array used to test for reserved word",
       documentation_snippet: "type Token_Flag_Array is array (Token_Type) of Boolean;",
       }   ,
   ]
,subtypes:    [
       {
       name: "Token_Class_After_SM",
       qualified_name: "Scans.Token_Class_After_SM",
       signature: "scans.token_class_after_sm",
       enclosing: "",
       is_private: false,
       documentation: "Tokens which always, or almost always, appear after a semicolon. Used\nin the Resync_Past_Semicolon routine to avoid gobbling up stuff when\na semicolon is missing. Of significance only for error recovery.",
       documentation_snippet: "subtype Token_Class_After_SM is\n  Token_Type range Tok_Less_Less .. Tok_EOF;",
       }   ,
       {
       name: "Token_Class_Atkwd",
       qualified_name: "Scans.Token_Class_Atkwd",
       signature: "scans.token_class_atkwd",
       enclosing: "",
       is_private: false,
       documentation: "Attribute keywords. This class includes keywords which can be used\nas an Attribute_Designator, namely DELTA, DIGITS and RANGE",
       documentation_snippet: "subtype Token_Class_Atkwd is\n  Token_Type range Tok_Delta .. Tok_Range;",
       }   ,
       {
       name: "Token_Class_Binary_Addop",
       qualified_name: "Scans.Token_Class_Binary_Addop",
       signature: "scans.token_class_binary_addop",
       enclosing: "",
       is_private: false,
       documentation: "Binary adding operator (& + -)",
       documentation_snippet: "subtype Token_Class_Binary_Addop is\n  Token_Type range Tok_Ampersand .. Tok_Plus;",
       }   ,
       {
       name: "Token_Class_Chtok",
       qualified_name: "Scans.Token_Class_Chtok",
       signature: "scans.token_class_chtok",
       enclosing: "",
       is_private: false,
       documentation: "Choice tokens. These tokens signal a choice when used in an Aggregate",
       documentation_snippet: "subtype Token_Class_Chtok is\n  Token_Type range Tok_Arrow .. Tok_Dot_Dot;",
       }   ,
       {
       name: "Token_Class_Consk",
       qualified_name: "Scans.Token_Class_Consk",
       signature: "scans.token_class_consk",
       enclosing: "",
       is_private: false,
       documentation: "Keywords which can start constraint\n  (left paren, delta, digits, range)",
       documentation_snippet: "subtype Token_Class_Consk is\n  Token_Type range Tok_Left_Paren .. Tok_Range;",
       }   ,
       {
       name: "Token_Class_Cterm",
       qualified_name: "Scans.Token_Class_Cterm",
       signature: "scans.token_class_cterm",
       enclosing: "",
       is_private: false,
       documentation: "Choice terminators. These tokens terminate a choice. This is used for\nerror recovery purposes (if we encounter an error in a Choice, we\nsimply scan to the next Cterm token).",
       documentation_snippet: "subtype Token_Class_Cterm is\n  Token_Type range Tok_EOF .. Tok_Vertical_Bar;",
       }   ,
       {
       name: "Token_Class_Cunit",
       qualified_name: "Scans.Token_Class_Cunit",
       signature: "scans.token_class_cunit",
       enclosing: "",
       is_private: false,
       documentation: "Tokens which can begin a compilation unit",
       documentation_snippet: "subtype Token_Class_Cunit is\n  Token_Type range Tok_Function .. Tok_Separate;",
       }   ,
       {
       name: "Token_Class_Deckn",
       qualified_name: "Scans.Token_Class_Deckn",
       signature: "scans.token_class_deckn",
       enclosing: "",
       is_private: false,
       documentation: "Keywords which start a declaration but can't start a compilation unit",
       documentation_snippet: "subtype Token_Class_Deckn is\n  Token_Type range Tok_Entry .. Tok_Use;",
       }   ,
       {
       name: "Token_Class_Declk",
       qualified_name: "Scans.Token_Class_Declk",
       signature: "scans.token_class_declk",
       enclosing: "",
       is_private: false,
       documentation: "Keywords which start a declaration",
       documentation_snippet: "subtype Token_Class_Declk is\n  Token_Type range Tok_Entry .. Tok_Procedure;",
       }   ,
       {
       name: "Token_Class_Desig",
       qualified_name: "Scans.Token_Class_Desig",
       signature: "scans.token_class_desig",
       enclosing: "",
       is_private: false,
       documentation: "Token which can be a Designator (identifier, operator symbol)",
       documentation_snippet: "subtype Token_Class_Desig is\n  Token_Type range Tok_Operator_Symbol .. Tok_Identifier;",
       }   ,
       {
       name: "Token_Class_Eterm",
       qualified_name: "Scans.Token_Class_Eterm",
       signature: "scans.token_class_eterm",
       enclosing: "",
       is_private: false,
       documentation: "Expression terminators. These tokens can never appear within a simple\nexpression. This is used for error recovery purposes (if we encounter\nan error in an expression, we simply scan to the next Eterm token).",
       documentation_snippet: "subtype Token_Class_Eterm is\n  Token_Type range Tok_Colon_Equal .. Tok_Semicolon;",
       }   ,
       {
       name: "Token_Class_Labeled_Stmt",
       qualified_name: "Scans.Token_Class_Labeled_Stmt",
       signature: "scans.token_class_labeled_stmt",
       enclosing: "",
       is_private: false,
       documentation: "Tokens which start labeled statements",
       documentation_snippet: "subtype Token_Class_Labeled_Stmt is\n  Token_Type range Tok_Begin .. Tok_While;",
       }   ,
       {
       name: "Token_Class_Lit_Or_Name",
       qualified_name: "Scans.Token_Class_Lit_Or_Name",
       signature: "scans.token_class_lit_or_name",
       enclosing: "",
       is_private: false,
       documentation: "",
       documentation_snippet: "subtype Token_Class_Lit_Or_Name is\n  Token_Type range Tok_Integer_Literal .. Tok_Identifier;",
       }   ,
       {
       name: "Token_Class_Literal",
       qualified_name: "Scans.Token_Class_Literal",
       signature: "scans.token_class_literal",
       enclosing: "",
       is_private: false,
       documentation: "Literal",
       documentation_snippet: "subtype Token_Class_Literal is\n  Token_Type range Tok_Integer_Literal .. Tok_Operator_Symbol;",
       }   ,
       {
       name: "Token_Class_Logop",
       qualified_name: "Scans.Token_Class_Logop",
       signature: "scans.token_class_logop",
       enclosing: "",
       is_private: false,
       documentation: "Logical operator (and, or, xor)",
       documentation_snippet: "subtype Token_Class_Logop is\n  Token_Type range Tok_And .. Tok_Xor;",
       }   ,
       {
       name: "Token_Class_Mulop",
       qualified_name: "Scans.Token_Class_Mulop",
       signature: "scans.token_class_mulop",
       enclosing: "",
       is_private: false,
       documentation: "Multiplying operator",
       documentation_snippet: "subtype Token_Class_Mulop is\n  Token_Type range Tok_Asterisk .. Tok_Slash;",
       }   ,
       {
       name: "Token_Class_Name",
       qualified_name: "Scans.Token_Class_Name",
       signature: "scans.token_class_name",
       enclosing: "",
       is_private: false,
       documentation: "First token of name (4.1),\n  (identifier, char literal, operator symbol)",
       documentation_snippet: "subtype Token_Class_Name is\n  Token_Type range Tok_Char_Literal .. Tok_Identifier;",
       }   ,
       {
       name: "Token_Class_Namext",
       qualified_name: "Scans.Token_Class_Namext",
       signature: "scans.token_class_namext",
       enclosing: "",
       is_private: false,
       documentation: "Name extension tokens. These are tokens which can appear immediately\nafter a name to extend it recursively (period, quote, left paren)",
       documentation_snippet: "subtype Token_Class_Namext is\n  Token_Type range Tok_Dot .. Tok_Left_Paren;",
       }   ,
       {
       name: "Token_Class_Numeric_Literal",
       qualified_name: "Scans.Token_Class_Numeric_Literal",
       signature: "scans.token_class_numeric_literal",
       enclosing: "",
       is_private: false,
       documentation: "Numeric literal",
       documentation_snippet: "subtype Token_Class_Numeric_Literal is\n  Token_Type range Tok_Integer_Literal .. Tok_Real_Literal;",
       }   ,
       {
       name: "Token_Class_Relop",
       qualified_name: "Scans.Token_Class_Relop",
       signature: "scans.token_class_relop",
       enclosing: "",
       is_private: false,
       documentation: "Relational operator (= /= < <= > >= not, in plus <> to catch misuse\nof Pascal style not equal operator).",
       documentation_snippet: "subtype Token_Class_Relop is\n  Token_Type range Tok_Less .. Tok_Box;",
       }   ,
       {
       name: "Token_Class_Sterm",
       qualified_name: "Scans.Token_Class_Sterm",
       signature: "scans.token_class_sterm",
       enclosing: "",
       is_private: false,
       documentation: "Simple_Expression terminators. A Simple_Expression must be followed\nby a token in this class, or an error message is issued complaining\nabout a missing binary operator.",
       documentation_snippet: "subtype Token_Class_Sterm is\n  Token_Type range Tok_Delta .. Tok_Dot_Dot;",
       }   ,
       {
       name: "Token_Class_Unary_Addop",
       qualified_name: "Scans.Token_Class_Unary_Addop",
       signature: "scans.token_class_unary_addop",
       enclosing: "",
       is_private: false,
       documentation: "Unary adding operator (+ -)",
       documentation_snippet: "subtype Token_Class_Unary_Addop is\n  Token_Type range Tok_Minus .. Tok_Plus;",
       }   ,
   ]
,constants:    [
       {
       name: "Is_Reserved_Keyword",
       qualified_name: "Scans.Is_Reserved_Keyword",
       signature: "scans.is_reserved_keyword",
       enclosing: "",
       is_private: false,
       documentation: "Flag array used to test for reserved word",
       documentation_snippet: "Is_Reserved_Keyword : constant Token_Flag_Array :=\n                        Token_Flag_Array'\n                          (Tok_Mod      .. Tok_Rem      => True,\n                           Tok_New      .. Tok_Null     => True,\n                           Tok_Delta    .. Tok_Range    => True,\n                           Tok_And      .. Tok_Xor      => True,\n                           Tok_In       .. Tok_Not      => True,\n                           Tok_Abstract .. Tok_Then     => True,\n                           Tok_Abort    .. Tok_Separate => True,\n                           others                       => False);",
       }   ,
   ]
,variables:    [
       {
       name: "Based_Literal_Uses_Colon",
       qualified_name: "Scans.Based_Literal_Uses_Colon",
       signature: "scans.based_literal_uses_colon",
       enclosing: "",
       is_private: false,
       documentation: "Valid only when Token = Tok_Integer_Literal or Tok_Real_Literal. Set\nTrue only for the case of a based literal using ':' instead of '#'.",
       documentation_snippet: "Based_Literal_Uses_Colon : Boolean;",
       }   ,
       {
       name: "Character_Code",
       qualified_name: "Scans.Character_Code",
       signature: "scans.character_code",
       enclosing: "",
       is_private: false,
       documentation: "Valid only when Token is Tok_Char_Literal. Contains the value of the\nscanned literal.",
       documentation_snippet: "Character_Code : Char_Code;",
       }   ,
       {
       name: "Checksum",
       qualified_name: "Scans.Checksum",
       signature: "scans.checksum",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Used to accumulate a CRC representing the tokens in the source\n file being compiled. This CRC includes only program tokens, and\n excludes comments.",
       documentation_snippet: "Checksum : Word := 0;",
       }   ,
       {
       name: "Comment_Id",
       qualified_name: "Scans.Comment_Id",
       signature: "scans.comment_id",
       enclosing: "",
       is_private: false,
       documentation: "Valid only when Token = Tok_Comment. Store the string that follows\nthe \"--\" of a comment when scanning project files.\n\nIs it really right for this to be a Name rather than a String, what\nabout the case of Wide_Wide_Characters???",
       documentation_snippet: "Comment_Id : Name_Id := No_Name;",
       }   ,
       {
       name: "Current_Line_Start",
       qualified_name: "Scans.Current_Line_Start",
       signature: "scans.current_line_start",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Pointer to first character of line containing current token",
       documentation_snippet: "Current_Line_Start : Source_Ptr := No_Location;",
       }   ,
       {
       name: "First_Non_Blank_Location",
       qualified_name: "Scans.First_Non_Blank_Location",
       signature: "scans.first_non_blank_location",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Location of first non-blank character on the line containing the\n current token (i.e. the location of the character whose column number\n is stored in Start_Column).",
       documentation_snippet: "First_Non_Blank_Location : Source_Ptr := No_Location;",
       }   ,
       {
       name: "Inside_Depends",
       qualified_name: "Scans.Inside_Depends",
       signature: "scans.inside_depends",
       enclosing: "",
       is_private: false,
       documentation: "Flag set True for parsing the argument of a Depends pragma or aspect\n(used to allow/require non-standard style rules for =>+ with -gnatyt).",
       documentation_snippet: "Inside_Depends : Boolean := False;",
       }   ,
       {
       name: "Inside_If_Expression",
       qualified_name: "Scans.Inside_If_Expression",
       signature: "scans.inside_if_expression",
       enclosing: "",
       is_private: false,
       documentation: "This is a counter that is set non-zero while scanning out an if\nexpression (incremented on entry, decremented on exit). It is used to\ndisconnect format checks that normally apply to keywords THEN, ELSE etc.",
       documentation_snippet: "Inside_If_Expression : Nat := 0;",
       }   ,
       {
       name: "Int_Literal_Value",
       qualified_name: "Scans.Int_Literal_Value",
       signature: "scans.int_literal_value",
       enclosing: "",
       is_private: false,
       documentation: "Valid only when Token = Tok_Integer_Literal, contains the value of the\nscanned literal.",
       documentation_snippet: "Int_Literal_Value : Uint;",
       }   ,
       {
       name: "Prev_Token",
       qualified_name: "Scans.Prev_Token",
       signature: "scans.prev_token",
       enclosing: "",
       is_private: false,
       documentation: "Type of previous token",
       documentation_snippet: "Prev_Token : Token_Type := No_Token;",
       }   ,
       {
       name: "Prev_Token_Ptr",
       qualified_name: "Scans.Prev_Token_Ptr",
       signature: "scans.prev_token_ptr",
       enclosing: "",
       is_private: false,
       documentation: "Pointer to first character of previous token",
       documentation_snippet: "Prev_Token_Ptr : Source_Ptr;",
       }   ,
       {
       name: "Real_Literal_Value",
       qualified_name: "Scans.Real_Literal_Value",
       signature: "scans.real_literal_value",
       enclosing: "",
       is_private: false,
       documentation: "Valid only when Token is Tok_Real_Literal, contains the value of the\nscanned literal.",
       documentation_snippet: "Real_Literal_Value : Ureal;",
       }   ,
       {
       name: "Scan_Ptr",
       qualified_name: "Scans.Scan_Ptr",
       signature: "scans.scan_ptr",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Current scan pointer location. After a call to Scan, this points\n just past the end of the token just scanned.",
       documentation_snippet: "Scan_Ptr : Source_Ptr := No_Location;",
       }   ,
       {
       name: "Special_Character",
       qualified_name: "Scans.Special_Character",
       signature: "scans.special_character",
       enclosing: "",
       is_private: false,
       documentation: "Valid only when Token = Tok_Special. Returns one of the characters\n'#', '$', '?', '@', '`', '\\', '^', '~', or '_'.\n\nWhy only this set? What about wide characters???",
       documentation_snippet: "Special_Character : Character;",
       }   ,
       {
       name: "Start_Column",
       qualified_name: "Scans.Start_Column",
       signature: "scans.start_column",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Starting column number (zero origin) of the first non-blank character\n on the line containing the current token. This is used for error\n recovery circuits which depend on looking at the column line up.",
       documentation_snippet: "Start_Column : Column_Number := No_Column_Number;",
       }   ,
       {
       name: "String_Literal_Id",
       qualified_name: "Scans.String_Literal_Id",
       signature: "scans.string_literal_id",
       enclosing: "",
       is_private: false,
       documentation: "Valid only when Token = Tok_String_Literal or Tok_Operator_Symbol.\nContains the Id for currently scanned string value.",
       documentation_snippet: "String_Literal_Id : String_Id;",
       }   ,
       {
       name: "Token",
       qualified_name: "Scans.Token",
       signature: "scans.token",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Type of current token",
       documentation_snippet: "Token : Token_Type := No_Token;",
       }   ,
       {
       name: "Token_Name",
       qualified_name: "Scans.Token_Name",
       signature: "scans.token_name",
       enclosing: "",
       is_private: false,
       documentation: "For identifiers, this is set to the Name_Id of the identifier scanned.\nFor all other tokens, Token_Name is set to Error_Name. Note that it\nwould be possible for the caller to extract this information from\nToken_Node. We set Token_Name separately for two reasons. First it\nallows a quicker test for a specific identifier. Second, it allows\na version of the parser to be built that does not build tree nodes,\nusable as a syntax checker.",
       documentation_snippet: "Token_Name : Name_Id := No_Name;",
       }   ,
       {
       name: "Token_Node",
       qualified_name: "Scans.Token_Node",
       signature: "scans.token_node",
       enclosing: "",
       is_private: false,
       documentation: "Node table Id for the current token. This is set only if the current\ntoken is one for which the scanner constructs a node (i.e. it is an\nidentifier, operator symbol, or literal). For other token types,\nToken_Node is undefined.",
       documentation_snippet: "Token_Node : Node_Id := Empty;",
       }   ,
       {
       name: "Token_Ptr",
       qualified_name: "Scans.Token_Ptr",
       signature: "scans.token_ptr",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Pointer to first character of current token",
       documentation_snippet: "Token_Ptr : Source_Ptr := No_Location;",
       }   ,
       {
       name: "Type_Token_Location",
       qualified_name: "Scans.Type_Token_Location",
       signature: "scans.type_token_location",
       enclosing: "",
       is_private: false,
       documentation: "init for -gnatVa\n Within a type declaration, gives the location of the TYPE keyword that\n opened the type declaration. Used in checking the end column of a record\n declaration, which can line up either with the TYPE keyword, or with the\n start of the line containing the RECORD keyword.",
       documentation_snippet: "Type_Token_Location : Source_Ptr := No_Location;",
       }   ,
       {
       name: "Version_To_Be_Found",
       qualified_name: "Scans.Version_To_Be_Found",
       signature: "scans.version_to_be_found",
       enclosing: "",
       is_private: false,
       documentation: "This flag is True if the scanner is still looking for an RCS version\nnumber in a comment. Normally it is initialized to False so that this\ncircuit is not activated. If the -dv switch is set, then this flag is\ninitialized to True, and then reset when the version number is found.\nWe do things this way to minimize the impact on comment scanning.",
       documentation_snippet: "Version_To_Be_Found : Boolean;",
       }   ,
       {
       name: "Wide_Character_Found",
       qualified_name: "Scans.Wide_Character_Found",
       signature: "scans.wide_character_found",
       enclosing: "",
       is_private: false,
       documentation: "Valid only when Token = Tok_String_Literal. Set True if wide character\nfound (i.e. a character that does not fit in Character, but fits in\nWide_Wide_Character).",
       documentation_snippet: "Wide_Character_Found : Boolean := False;",
       }   ,
       {
       name: "Wide_Wide_Character_Found",
       qualified_name: "Scans.Wide_Wide_Character_Found",
       signature: "scans.wide_wide_character_found",
       enclosing: "",
       is_private: false,
       documentation: "Valid only when Token = Tok_String_Literal. Set True if wide wide\ncharacter found (i.e. a character that does not fit in Character or\nWide_Character).",
       documentation_snippet: "Wide_Wide_Character_Found : Boolean := False;",
       }   ,
   ]
,}
---
